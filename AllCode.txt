===== ./Pivot_PointV2.xcdatamodeld/dta.swift =====



===== ./Pivot_PointV2.xcdatamodeld/Pivot_PointV2.xcdatamodel/contents =====
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="23788.4" systemVersion="24G90" minimumToolsVersion="Automatic" sourceLanguage="Swift" userDefinedModelVersionIdentifier="Pivot_PointV2">
    <entity name="DTAReport" representedClassName="DTAReport" syncable="YES" codeGenerationType="class">
        <attribute name="activity" attributeType="String"/>
        <attribute name="areaBetweenPointsSafeForWork" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="areaSafeForWorkComment" optional="YES" attributeType="String"/>
        <attribute name="assessedBy" attributeType="String"/>
        <attribute name="assessedDistanceFromWorkArea" attributeType="String"/>
        <attribute name="assessedMin1_5TreeLengths" attributeType="String"/>
        <attribute name="assessedTLComment" optional="YES" attributeType="String"/>
        <attribute name="assessmentStartEndSpot" attributeType="String"/>
        <attribute name="comments" optional="YES" attributeType="String"/>
        <attribute name="deviceType" optional="YES" attributeType="String"/>
        <attribute name="dtaMarkingProtocolComment" optional="YES" attributeType="String"/>
        <attribute name="dtaMarkingProtocolFollowed" attributeType="String"/>
        <attribute name="dtfCompletedBy" optional="YES" attributeType="String"/>
        <attribute name="estimatedTreesFelled" optional="YES" attributeType="Integer 16" defaultValueString="0" usesScalarValueType="YES"/>
        <attribute name="fireCenter" optional="YES" attributeType="String"/>
        <attribute name="fireNumber" attributeType="String"/>
        <attribute name="id" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="levelOfDisturbance" attributeType="String"/>
        <attribute name="locationDDM" attributeType="String"/>
        <attribute name="lodLowHazards" optional="YES" attributeType="String"/>
        <attribute name="lodMediumFirLarchPineSpruce" optional="YES" attributeType="String"/>
        <attribute name="lodMediumRedYellowCedar" optional="YES" attributeType="String"/>
        <attribute name="manualDateTime" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="noWorkZones" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="noWorkZonesPresent" optional="YES" attributeType="String"/>
        <attribute name="primaryHazardsPresent" attributeType="String"/>
        <attribute name="reassessmentNeeded" attributeType="String"/>
        <attribute name="reportTitle" attributeType="String"/>
        <attribute name="saoBriefedToCrew" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="saoComment" optional="YES" attributeType="String"/>
        <attribute name="saoOverview" attributeType="String"/>
        <relationship name="fireFolder" optional="YES" maxCount="1" deletionRule="Nullify" destinationEntity="FireFolder" inverseName="dtaReports" inverseEntity="FireFolder"/>
        <relationship name="fuelTypes" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="FuelTypeSelection" inverseName="dtaReport" inverseEntity="FuelTypeSelection"/>
        <relationship name="mediaAttachments" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="MediaAttachment" inverseName="dtaReport" inverseEntity="MediaAttachment"/>
        <relationship name="waypoints" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="DTAWaypoint" inverseName="dtaReport" inverseEntity="DTAWaypoint"/>
    </entity>
    <entity name="DTAWaypoint" representedClassName="DTAWaypoint" syncable="YES" codeGenerationType="class">
        <attribute name="id" optional="YES" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="isEndPoint" optional="YES" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="isSpotPoint" optional="YES" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="isStartPoint" optional="YES" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="isStopPoint" optional="YES" attributeType="Boolean" usesScalarValueType="YES"/>
        <attribute name="label" optional="YES" attributeType="String"/>
        <attribute name="latitude" attributeType="Double" usesScalarValueType="YES"/>
        <attribute name="locationNotes" optional="YES" attributeType="String"/>
        <attribute name="longitude" attributeType="Double" usesScalarValueType="YES"/>
        <relationship name="dtaReport" maxCount="1" deletionRule="Nullify" destinationEntity="DTAReport" inverseName="waypoints" inverseEntity="DTAReport"/>
        <relationship name="waypoints" optional="YES" toMany="YES" deletionRule="Cascade" ordered="YES" destinationEntity="DTAWaypoint" inverseName="waypoints" inverseEntity="DTAWaypoint"/>
    </entity>
    <entity name="FireCSV" representedClassName="FireCSV" syncable="YES" codeGenerationType="class">
        <attribute name="createdDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="csvData" optional="YES" attributeType="Binary"/>
        <attribute name="fileName" optional="YES" attributeType="String"/>
        <attribute name="id" optional="YES" attributeType="UUID"/>
        <relationship name="folder" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="FireFolder" inverseName="csvExports" inverseEntity="FireFolder"/>
    </entity>
    <entity name="FireFolder" representedClassName="FireFolder" syncable="YES" codeGenerationType="class">
        <attribute name="date" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="erpDocumentPath" optional="YES" attributeType="String"/>
        <attribute name="fireCenter" optional="YES" attributeType="String"/>
        <attribute name="fireNumber" optional="YES" attributeType="String"/>
        <attribute name="folderName" optional="YES" attributeType="String"/>
        <attribute name="iapDocumentPath" optional="YES" attributeType="String"/>
        <attribute name="id" attributeType="UUID" usesScalarValueType="NO"/>
        <relationship name="csvExports" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="FireCSV" inverseName="folder" inverseEntity="FireCSV"/>
        <relationship name="dtaReports" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="DTAReport" inverseName="fireFolder" inverseEntity="DTAReport"/>
        <relationship name="kmlExports" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="FireKML" inverseName="folder" inverseEntity="FireKML"/>
        <relationship name="pdfs" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="FirePDF" inverseName="folder" inverseEntity="FirePDF"/>
    </entity>
    <entity name="FireKML" representedClassName="FireKML" syncable="YES" codeGenerationType="class">
        <attribute name="createdDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="fileName" optional="YES" attributeType="String"/>
        <attribute name="id" optional="YES" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="kmlData" optional="YES" attributeType="Binary"/>
        <relationship name="folder" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="FireFolder" inverseName="kmlExports" inverseEntity="FireFolder"/>
    </entity>
    <entity name="FireLog" representedClassName="FireLog" syncable="YES" codeGenerationType="class">
        <attribute name="id" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="latitude" attributeType="Double"/>
        <attribute name="longitude" attributeType="Double"/>
        <attribute name="notes" optional="YES" attributeType="String"/>
        <attribute name="title" optional="YES" attributeType="String"/>
    </entity>
    <entity name="FirePDF" representedClassName="FirePDF" syncable="YES" codeGenerationType="class">
        <attribute name="createdDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="erpDocumentPath" optional="YES" attributeType="String"/>
        <attribute name="fileName" optional="YES" attributeType="String"/>
        <attribute name="iapDocumentPath" optional="YES" attributeType="String"/>
        <attribute name="id" optional="YES" attributeType="UUID"/>
        <attribute name="pdfData" optional="YES" attributeType="Binary"/>
        <attribute name="url" optional="YES" attributeType="String"/>
        <relationship name="folder" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="FireFolder" inverseName="pdfs" inverseEntity="FireFolder"/>
    </entity>
    <entity name="FuelTypeSelection" representedClassName="FuelTypeSelection" syncable="YES" codeGenerationType="class">
        <attribute name="fuelType" optional="YES" attributeType="String"/>
        <attribute name="id" optional="YES" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="percentage" optional="YES" attributeType="Integer 16" defaultValueString="0" usesScalarValueType="YES"/>
        <relationship name="dtaReport" optional="YES" maxCount="1" deletionRule="Nullify" destinationEntity="DTAReport" inverseName="fuelTypes" inverseEntity="DTAReport"/>
    </entity>
    <entity name="MediaAttachment" representedClassName="MediaAttachment" syncable="YES" codeGenerationType="class">
        <attribute name="fileName" optional="YES" attributeType="String"/>
        <attribute name="fileURL" optional="YES" attributeType="String"/>
        <attribute name="id" optional="YES" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="mediaType" optional="YES" attributeType="String"/>
        <attribute name="photoAltitude" optional="YES" attributeType="String"/>
        <attribute name="photoDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="photoLatitude" optional="YES" attributeType="String"/>
        <attribute name="photoLocationDDM" optional="YES" attributeType="String"/>
        <attribute name="photoLongitude" optional="YES" attributeType="String"/>
        <attribute name="photoOrientation" optional="YES" attributeType="String"/>
        <attribute name="photoTimestamp" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <relationship name="dtaReport" maxCount="1" deletionRule="Nullify" destinationEntity="DTAReport" inverseName="mediaAttachments" inverseEntity="DTAReport"/>
    </entity>
</model>


===== ./PivotPointV3/SingleSelectPickerView.swift =====
import SwiftUI

struct SingleSelectPickerView: View {
    let title: String
    let options: [String]
    @Binding var selectedOption: String
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        List(options, id: \.self) { option in
            Button(action: {
                selectedOption = option
                dismiss()
            }) {
                HStack {
                    Text(option)
                    Spacer()
                    if selectedOption == option {
                        Image(systemName: "checkmark")
                            .foregroundColor(.accentColor)
                    }
                }
            }
            .buttonStyle(PressedHighlightButtonStyle())
            .foregroundColor(.primary)
            .listRowBackground(selectedOption == option ? Color.accentColor.opacity(0.35) : Color(uiColor: .systemBackground))
        }
        .navigationTitle(title)
        .navigationBarTitleDisplayMode(.inline)
    }
}



===== ./PivotPointV3/ReportMetadataSectionView.swift =====
import SwiftUI

struct ReportMetadataSectionView: View {
    @ObservedObject var viewModel: DTAReportViewModel
    
    var body: some View {
        Section("Report Information") {
            // NON-EDITABLE: Auto-generated report title
            VStack(alignment: .leading, spacing: 4) {
                Text("Report Title").font(.caption).foregroundColor(.secondary)
                Text(viewModel.reportTitle)
                    .foregroundColor(.green)
                    .font(.body)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
            }
            
            // Auto-populated and GREEN
            VStack(alignment: .leading, spacing: 4) {
                Text("Fire Number").font(.caption).foregroundColor(.secondary)
                Text(viewModel.fireNumber.isEmpty ? "N/A" : viewModel.fireNumber)
                    .foregroundColor(.green)
                    .font(.body)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
            }
            
            // Auto-populated and GREEN
            VStack(alignment: .leading, spacing: 4) {
                Text("Fire Centre").font(.caption).foregroundColor(.secondary)
                Text(viewModel.fireCenter.isEmpty ? "N/A" : viewModel.fireCenter)
                    .foregroundColor(.green)
                    .font(.body)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
            }
            
            // NON-EDITABLE: Auto-populated from user profile
            VStack(alignment: .leading, spacing: 4) {
                Text("Assessed By").font(.caption).foregroundColor(.secondary)
                Text(viewModel.assessedBy)
                    .foregroundColor(.green)
                    .font(.body)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("DTF Completed By").font(.caption).foregroundColor(.secondary)
                TextField("Enter DTF completion details", text: $viewModel.dtfCompletedBy)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }
            
            // NON-EDITABLE: Auto-populated date/time in 24-hour format
            VStack(alignment: .leading, spacing: 4) {
                Text("Assessment Date/Time").font(.caption).foregroundColor(.secondary)
                Text(formatDateTime(viewModel.report.manualDateTime ?? Date()))
                    .foregroundColor(.green)
                    .font(.body)
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
            }
        }
    }
    
    private func formatDateTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm" // 24-hour format
        return formatter.string(from: date)
    }
}



===== ./PivotPointV3/AssessmentProtocolSectionView.swift =====
import SwiftUI

struct AssessmentProtocolSectionView: View {
    @ObservedObject var viewModel: DTAReportViewModel
    @State private var showNoWorkZoneAlert = false
    @State private var treesFelledTouched: Bool = false
    
    private let reassessmentOptions = ["", "Daily (active burning)", "Every 3 days (active burning)", "Not required"]
    
    private var hasStartAndEndPoints: Bool {
        let labels = Set(viewModel.waypointsArray.map { $0.label ?? "" })
        return labels.contains("Start") && labels.contains("End")
    }

    var body: some View {
        Section(header: Text("Assessment Protocol")) {
            NavigationLink(destination: SingleSelectPickerView(
                title: "DTA Marking Protocol",
                options: ["Yes", "No"],
                selectedOption: $viewModel.dtaMarkingProtocolFollowed
            )) {
                HStack {
                    Text("DTA Marking Protocol Followed?")
                    Spacer()
                    Text(viewModel.dtaMarkingProtocolFollowed.isEmpty ? "Select..." : viewModel.dtaMarkingProtocolFollowed)
                        .foregroundColor(.secondary)
                }
            }
            .foregroundColor(viewModel.dtaMarkingProtocolFollowed.isEmpty ? .primary : .green)
            .onChange(of: viewModel.dtaMarkingProtocolFollowed) { _, newValue in
                if newValue == "Yes" {
                    viewModel.dtaMarkingProtocolComment = ""
                }
            }
            
            if viewModel.dtaMarkingProtocolFollowed == "No" {
                VStack(alignment: .leading) {
                    Text("Indicate what alternative was used:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    TextEditor(text: $viewModel.dtaMarkingProtocolComment)
                        .frame(height: 100)
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                }
            }
            
            HStack {
                Text("Estimated Trees Felled")
                Spacer()
                if treesFelledTouched || viewModel.estimatedTreesFelled > 0 {
                    Text("\(viewModel.estimatedTreesFelled)")
                        .foregroundColor(.green)
                }
                Stepper("Stepper", value: $viewModel.estimatedTreesFelled, in: 0...9999)
                    .labelsHidden()
            }
            .foregroundColor((treesFelledTouched || viewModel.estimatedTreesFelled > 0) ? .green : .primary)
            .onAppear {
                if viewModel.estimatedTreesFelled > 0 {
                    treesFelledTouched = true
                }
            }
            .onChange(of: viewModel.estimatedTreesFelled) { _, _ in
                treesFelledTouched = true
            }

            NavigationLink(destination: SingleSelectPickerView(
                title: "No Work Zones Present?",
                options: ["Yes", "No"],
                selectedOption: $viewModel.noWorkZonesPresent
            )) {
                HStack {
                    Text("No Work Zones Present?")
                    Spacer()
                    Text(viewModel.noWorkZonesPresent.isEmpty ? "Select..." : viewModel.noWorkZonesPresent)
                        .foregroundColor(.secondary)
                }
            }
            .foregroundColor(viewModel.noWorkZonesPresent.isEmpty ? .primary : .green)

            if viewModel.noWorkZonesPresent == "Yes" {
                Text("Add all No Work Zones as 'Spot' waypoints with photos if possible.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Toggle("No Work Zones Identified & Communicated?", isOn: $viewModel.noWorkZones)
                    .foregroundColor(viewModel.noWorkZones ? .green : .primary)
                    .onChange(of: viewModel.noWorkZones) { _, identified in
                        if !identified {
                            showNoWorkZoneAlert = true
                        }
                    }
                    .alert("Communication Required", isPresented: $showNoWorkZoneAlert) {
                        Button("OK", role: .cancel) {}
                    } message: {
                        Text("You must identify and communicate all No Work Zones to your crew.")
                    }
            }

            NavigationLink(destination: SingleSelectPickerView(
                title: "Assessed min. 1.5 TL",
                options: ["Yes", "No"],
                selectedOption: $viewModel.assessedMin1_5TreeLengths
            )) {
                HStack {
                    Text("Assessed min. 1.5 TL from work area")
                    Spacer()
                    Text(viewModel.assessedMin1_5TreeLengths.isEmpty ? "Select..." : viewModel.assessedMin1_5TreeLengths)
                        .foregroundColor(.secondary)
                }
            }
            .foregroundColor(viewModel.assessedMin1_5TreeLengths.isEmpty ? .primary : .green)
            .onChange(of: viewModel.assessedMin1_5TreeLengths) { _, newValue in
                if newValue == "Yes" {
                    viewModel.assessedTLComment = ""
                }
            }

            if viewModel.assessedMin1_5TreeLengths == "No" {
                VStack(alignment: .leading) {
                    Text("Explain why:")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    TextEditor(text: $viewModel.assessedTLComment)
                        .frame(height: 100)
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                }
            }

            NavigationLink(destination: SingleSelectPickerView(
                title: "Distance from Work Area",
                options: DTAPicklists.assessDistanceFromWorkAreaOptions,
                selectedOption: $viewModel.assessedDistanceFromWorkArea
            )) {
                HStack {
                    Text("Distance from Work Area")
                    Spacer()
                    Text(viewModel.assessedDistanceFromWorkArea.isEmpty ? "Select..." : viewModel.assessedDistanceFromWorkArea)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.trailing)
                }
            }
            .foregroundColor(viewModel.assessedDistanceFromWorkArea.isEmpty ? .primary : .green)
            
            if hasStartAndEndPoints {
                Toggle("Area between start and end safe for work?", isOn: $viewModel.areaBetweenPointsSafeForWork)
                    .foregroundColor(viewModel.areaBetweenPointsSafeForWork ? .green : .primary)
                    .onChange(of: viewModel.areaBetweenPointsSafeForWork) { _, isSafe in
                        if isSafe {
                            viewModel.areaSafeForWorkComment = ""
                        }
                    }
                
                if !viewModel.areaBetweenPointsSafeForWork {
                    VStack(alignment: .leading) {
                        Text("Explain why not:")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        TextEditor(text: $viewModel.areaSafeForWorkComment)
                            .frame(height: 100)
                            .overlay(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                            )
                    }
                }
            }
            
            NavigationLink(destination: SingleSelectPickerView(
                title: "Reassessment Needed",
                options: reassessmentOptions.filter { !$0.isEmpty },
                selectedOption: $viewModel.reassessmentNeeded
            )) {
                HStack {
                    Text("Reassessment Needed")
                    Spacer()
                    Text(viewModel.reassessmentNeeded.isEmpty ? "Select..." : viewModel.reassessmentNeeded)
                        .foregroundColor(.secondary)
                }
            }
            .foregroundColor(viewModel.reassessmentNeeded.isEmpty ? .primary : .green)
        }
    }
}



===== ./PivotPointV3/CoreData+Extensions.swift =====
import Foundation
import CoreData

extension DTAReport {
    var unwrappedReportTitle: String {
        reportTitle ?? "Untitled Report"
    }
    
    var mediaAttachmentsArray: [MediaAttachment] {
        let set = mediaAttachments as? Set<MediaAttachment> ?? []
        return set.sorted { ($0.photoTimestamp ?? Date()) < ($1.photoTimestamp ?? Date()) }
    }
    
    var waypointsArray: [DTAWaypoint] {
        let set = waypoints as? Set<DTAWaypoint> ?? []
        return set.sorted { ($0.label ?? "") < ($1.label ?? "") }
    }
}

extension FireFolder {
    var unwrappedName: String {
        folderName ?? "Untitled Fire Folder"
    }
    
    var dtaReportsArray: [DTAReport] {
        let set = dtaReports as? Set<DTAReport> ?? []
        return set.sorted { ($0.manualDateTime ?? Date()) > ($1.manualDateTime ?? Date()) }
    }
}

extension DTAWaypoint {
    var coordinateString: String {
        return String(format: "%.6f, %.6f", latitude, longitude)
    }

    var ddmCoordinateString: String {
        let latDegrees = Int(abs(latitude))
        let latMinutes = (abs(latitude) - Double(latDegrees)) * 60
        let latDirection = latitude >= 0 ? "N" : "S"
        
        let lonDegrees = Int(abs(longitude))
        let lonMinutes = (abs(longitude) - Double(lonDegrees)) * 60
        let lonDirection = longitude >= 0 ? "E" : "W"
        
        return String(format: "%d° %.3f' %@, %d° %.3f' %@",
                      latDegrees, latMinutes, latDirection,
                      lonDegrees, lonMinutes, lonDirection)
    }
}



===== ./PivotPointV3/DTAReportViewModel.swift =====
import SwiftUI
import CoreData
import PhotosUI
import Combine

struct IdentifiableImage: Identifiable {
    let id: UUID
    var image: UIImage
    let mediaAttachment: MediaAttachment
}

final class DTAReportViewModel: ObservableObject, Identifiable, Hashable {
    let id = UUID()
    let context: NSManagedObjectContext
    private let parentContext: NSManagedObjectContext

    @Published var report: DTAReport
    @Published var images: [IdentifiableImage] = []

    // Direct UI bindings
    @Published var reportTitle: String
    @Published var dtfCompletedBy: String
    @Published var fireNumber: String
    @Published var fireCenter: String
    @Published var assessedBy: String
    @Published var saoOverview: String
    @Published var saoBriefedToCrew: Bool
    @Published var saoComment: String
    @Published var primaryHazardsPresent: Set<String>
    @Published var activity: String
    @Published var comments: String
    @Published var dtaMarkingProtocolFollowed: String
    @Published var dtaMarkingProtocolComment: String
    @Published var estimatedTreesFelled: Int16
    @Published var noWorkZonesPresent: String
    @Published var noWorkZones: Bool
    @Published var assessedMin1_5TreeLengths: String
    @Published var assessedTLComment: String
    @Published var areaBetweenPointsSafeForWork: Bool
    @Published var areaSafeForWorkComment: String
    @Published var reassessmentNeeded: String
    
    @Published var levelOfDisturbance: String {
        didSet {
            handleLODChanges(from: oldValue)
        }
    }
    
    // MODIFIED: This is now a Set for multi-select, backed by the original String
    var lodLowHazardsSet: Set<String> {
        get {
            Set((report.lodLowHazards ?? "").split(separator: ";;").map(String.init))
        }
        set {
            report.lodLowHazards = newValue.sorted().joined(separator: ";;")
        }
    }
    
    @Published var lodMediumFirLarchPineSpruce: String
    @Published var lodMediumRedYellowCedar: String
    @Published var assessedDistanceFromWorkArea: String

    init(report: DTAReport, parentContext: NSManagedObjectContext, userSettings: UserSettings) {
        self.parentContext = parentContext
        self.context = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)
        self.context.parent = parentContext
        
        self.reportTitle = report.reportTitle ?? ""
        self.dtfCompletedBy = report.dtfCompletedBy ?? ""
        self.fireNumber = report.fireNumber ?? ""
        self.fireCenter = report.fireCenter ?? ""
        self.assessedBy = report.assessedBy ?? ""
        self.saoOverview = report.saoOverview ?? ""
        self.saoBriefedToCrew = report.saoBriefedToCrew
        self.saoComment = report.saoComment ?? ""
        self.primaryHazardsPresent = Set((report.primaryHazardsPresent ?? "").split(separator: ";;").map { String($0) }.filter { !$0.isEmpty })
        self.activity = report.activity ?? ""
        self.comments = report.comments ?? ""
        self.dtaMarkingProtocolFollowed = report.dtaMarkingProtocolFollowed ?? ""
        self.dtaMarkingProtocolComment = report.dtaMarkingProtocolComment ?? ""
        self.estimatedTreesFelled = report.estimatedTreesFelled
        self.noWorkZonesPresent = report.noWorkZonesPresent ?? ""
        self.noWorkZones = report.noWorkZones
        self.assessedMin1_5TreeLengths = report.assessedMin1_5TreeLengths ?? ""
        self.assessedTLComment = report.assessedTLComment ?? ""
        self.areaBetweenPointsSafeForWork = report.areaBetweenPointsSafeForWork
        self.areaSafeForWorkComment = report.areaSafeForWorkComment ?? ""
        self.reassessmentNeeded = report.reassessmentNeeded ?? ""
        self.levelOfDisturbance = report.levelOfDisturbance ?? ""
        self.lodMediumFirLarchPineSpruce = report.lodMediumFirLarchPineSpruce ?? ""
        self.lodMediumRedYellowCedar = report.lodMediumRedYellowCedar ?? ""
        self.assessedDistanceFromWorkArea = report.assessedDistanceFromWorkArea ?? ""
        
        self.report = self.context.object(with: report.objectID) as! DTAReport
        
        if self.assessedBy.isEmpty {
            self.assessedBy = userSettings.userName
        }
        loadImages()
    }

    private func handleLODChanges(from oldValue: String) {
        let notApplicable = "Not Applicable"
        
        switch levelOfDisturbance {
        case "VLR":
            report.lodLowHazards = notApplicable
            lodMediumFirLarchPineSpruce = notApplicable
            lodMediumRedYellowCedar = notApplicable
        case "Low":
            // Low Hazards remains editable, only Medium is locked.
            lodMediumFirLarchPineSpruce = notApplicable
            lodMediumRedYellowCedar = notApplicable
            if oldValue == "VLR" || oldValue == "High" {
                report.lodLowHazards = "" // Unlock
            }
        case "High":
            report.lodLowHazards = notApplicable
            lodMediumFirLarchPineSpruce = notApplicable
            lodMediumRedYellowCedar = notApplicable
        default: // Moderate or empty
            if oldValue == "VLR" || oldValue == "High" {
                report.lodLowHazards = ""
                lodMediumFirLarchPineSpruce = ""
                lodMediumRedYellowCedar = ""
            } else if oldValue == "Low" {
                lodMediumFirLarchPineSpruce = ""
                lodMediumRedYellowCedar = ""
            }
        }
    }
    
    func validateReport() -> [String] {
        var missingFields: [String] = []

        if saoOverview.isEmpty { missingFields.append("SAO Overview") }
        if primaryHazardsPresent.isEmpty { missingFields.append("Primary Hazards Present") }
        if activity.isEmpty { missingFields.append("Activity") }
        if levelOfDisturbance.isEmpty { missingFields.append("Level of Disturbance") }
        if dtaMarkingProtocolFollowed.isEmpty { missingFields.append("DTA Marking Protocol") }
        if noWorkZonesPresent.isEmpty { missingFields.append("No Work Zones Present") }
        if assessedMin1_5TreeLengths.isEmpty { missingFields.append("Assessed min. 1.5 TL") }

        return missingFields
    }
    
    func saveContext() {
        report.reportTitle = reportTitle
        report.dtfCompletedBy = dtfCompletedBy
        report.fireNumber = fireNumber
        report.fireCenter = fireCenter
        report.assessedBy = assessedBy
        report.saoOverview = saoOverview
        report.saoBriefedToCrew = saoBriefedToCrew
        report.saoComment = saoComment
        report.primaryHazardsPresent = primaryHazardsPresent.sorted().joined(separator: ";;")
        report.activity = activity
        report.comments = comments
        report.dtaMarkingProtocolFollowed = dtaMarkingProtocolFollowed
        report.dtaMarkingProtocolComment = dtaMarkingProtocolComment
        report.estimatedTreesFelled = estimatedTreesFelled
        report.noWorkZonesPresent = noWorkZonesPresent
        report.noWorkZones = noWorkZones
        report.assessedMin1_5TreeLengths = assessedMin1_5TreeLengths
        report.assessedTLComment = assessedTLComment
        report.areaBetweenPointsSafeForWork = areaBetweenPointsSafeForWork
        report.areaSafeForWorkComment = areaSafeForWorkComment
        report.reassessmentNeeded = reassessmentNeeded
        report.levelOfDisturbance = levelOfDisturbance
        report.lodMediumFirLarchPineSpruce = lodMediumFirLarchPineSpruce
        report.lodMediumRedYellowCedar = lodMediumRedYellowCedar
        report.assessedDistanceFromWorkArea = assessedDistanceFromWorkArea
        
        guard context.hasChanges else { return }
        do {
            try context.save()
            if parentContext.hasChanges { try parentContext.save() }
        } catch {
            print("Error autosaving context: \(error)")
        }
    }
    
    var waypointsArray: [DTAWaypoint] {
        (report.waypoints as? Set<DTAWaypoint> ?? []).sorted { $0.label ?? "" < $1.label ?? "" }
    }
    
    static func == (lhs: DTAReportViewModel, rhs: DTAReportViewModel) -> Bool {
        lhs.id == rhs.id
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    // Other helper functions are unchanged
    func addPhotoToWaypoint(_ waypoint: DTAWaypoint, data: Data) {}
    func findPhoto(for waypoint: DTAWaypoint) -> MediaAttachment? { return nil }
    func removeMediaAttachment(_ attachment: MediaAttachment) {}
    private func loadImages() {}
}



===== ./PivotPointV3/FuelTypeSelectionView.swift =====
import SwiftUI
import CoreData

struct FuelTypeSelectionView: View {
    @ObservedObject var report: DTAReport
    let context: NSManagedObjectContext

    private var selections: [FuelTypeSelection] {
        (report.fuelTypes as? Set<FuelTypeSelection> ?? []).sorted { $0.fuelType ?? "" < $1.fuelType ?? "" }
    }
    
    private var totalPercentage: Int {
        selections.reduce(0) { $0 + Int($1.percentage) }
    }

    var body: some View {
        Form {
            Section("Select Fuel Types") {
                ForEach(selections) { selection in
                    fuelTypeRow(for: selection)
                }
                
                if DTAPicklists.fuelTypeOptions.count > selections.count {
                    Menu("Add Fuel Type...") {
                        ForEach(DTAPicklists.fuelTypeOptions.filter { option in
                            !selections.contains { $0.fuelType == option }
                        }, id: \.self) { option in
                            Button(option) {
                                withAnimation {
                                    toggleSelection(for: option)
                                }
                            }
                        }
                    }
                }
            }
            
            if selections.count > 1 {
                Section("Total Percentage") {
                    HStack {
                        Text("Total")
                        Spacer()
                        Text("\(totalPercentage)%")
                            .foregroundColor(totalPercentage == 100 ? .green : .red)
                    }
                    if totalPercentage != 100 {
                        Text("Percentages must total 100%").font(.caption).foregroundColor(.red)
                    }
                }
            }
        }
        .navigationTitle("Fuel Types")
    }
    
    @ViewBuilder
    private func fuelTypeRow(for selection: FuelTypeSelection) -> some View {
        VStack {
            HStack {
                Text(selection.fuelType ?? "Unknown")
                Spacer()
                Button(role: .destructive) {
                    withAnimation {
                        toggleSelection(for: selection.fuelType ?? "")
                    }
                } label: { Image(systemName: "xmark.circle.fill") }
            }
            .buttonStyle(.plain)
            
            if selections.count > 1 {
                Picker("Percentage", selection: Binding(
                    get: { selection.percentage },
                    set: { newValue in
                        updatePercentage(for: selection, to: newValue)
                    }
                )) {
                    Text("25%").tag(Int16(25))
                    Text("50%").tag(Int16(50))
                    Text("75%").tag(Int16(75))
                }
                .pickerStyle(.segmented)
                .padding(.top, 5)
            }
        }
        .padding(.vertical, 4)
    }
    
    private func toggleSelection(for option: String) {
        // Manually notify observers that the report object will change.
        report.objectWillChange.send()
        
        let mutableFuelTypes = report.mutableSetValue(forKey: "fuelTypes")
        
        if let selectionToRemove = selections.first(where: { $0.fuelType == option }) {
            mutableFuelTypes.remove(selectionToRemove)
            context.delete(selectionToRemove)
        } else {
            let newSelection = FuelTypeSelection(context: context)
            newSelection.id = UUID()
            newSelection.fuelType = option
            newSelection.percentage = 0
            newSelection.dtaReport = report
            mutableFuelTypes.add(newSelection)
        }
        
        let currentSelections = mutableFuelTypes.allObjects as! [FuelTypeSelection]
        if currentSelections.count == 1 {
            currentSelections[0].percentage = 100
        } else if currentSelections.count > 1 {
            let basePercentage = 100 / currentSelections.count
            let remainder = 100 % currentSelections.count
            for (i, item) in currentSelections.sorted(by: { $0.fuelType ?? "" < $1.fuelType ?? "" }).enumerated() {
                item.percentage = Int16(basePercentage + (i < remainder ? 1 : 0))
            }
        }
        
        try? context.save()
    }
    
    private func updatePercentage(for selection: FuelTypeSelection, to newValue: Int16) {
        // Manually notify observers for instant feedback.
        report.objectWillChange.send()
        
        selection.percentage = newValue
        let currentSelections = self.selections
        
        if currentSelections.count == 2 {
            if let otherSelection = currentSelections.first(where: { $0.id != selection.id }) {
                otherSelection.percentage = 100 - newValue
            }
        } else if currentSelections.count > 2 {
            let otherSelections = currentSelections.filter { $0.id != selection.id }
            
            let remainingPercentage = 100 - Int(newValue)
            let numberOfOthers = otherSelections.count
            
            if numberOfOthers > 0 {
                let base = remainingPercentage / numberOfOthers
                let remainder = remainingPercentage % numberOfOthers
                for (i, item) in otherSelections.enumerated() {
                    item.percentage = Int16(base + (i < remainder ? 1 : 0))
                }
            }
        }
        
        try? context.save()
    }
}



===== ./PivotPointV3/LevelOfDisturbanceSectionView.swift =====
import SwiftUI

struct LevelOfDisturbanceSectionView: View {
    @ObservedObject var viewModel: DTAReportViewModel

    var body: some View {
        Section("Level of Disturbance") {
            NavigationLink(destination: SingleSelectPickerView(
                title: "Level of Disturbance",
                options: DTAPicklists.levelOfDisturbanceOptions,
                selectedOption: $viewModel.levelOfDisturbance
            )) {
                HStack {
                    Text("Level of Disturbance")
                    Spacer()
                    Text(viewModel.levelOfDisturbance.isEmpty ? "Select..." : viewModel.levelOfDisturbance)
                        .foregroundColor(.secondary)
                }
            }
            .foregroundColor(viewModel.levelOfDisturbance.isEmpty ? .primary : .green)

            if viewModel.levelOfDisturbance == "High" {
                lodHighInfoBox
            }

            if !viewModel.levelOfDisturbance.isEmpty {
                // MODIFIED: This now uses a MultiSelectPickerView
                NavigationLink(destination: MultiSelectPickerView(
                    title: "LoD Low Hazards",
                    options: DTAPicklists.lodLowHazardsOptions,
                    selection: $viewModel.lodLowHazardsSet
                )) {
                    HStack {
                        Text("LoD Low Hazards")
                        Spacer()
                        Text(lodLowHazardsSummary)
                            .foregroundColor(.secondary)
                    }
                }
                .disabled(viewModel.levelOfDisturbance == "VLR" || viewModel.levelOfDisturbance == "High")
                .foregroundColor(viewModel.lodLowHazardsSet.isEmpty && !["VLR", "High"].contains(viewModel.levelOfDisturbance) ? .primary : .green)

                NavigationLink(destination: SingleSelectPickerView(
                    title: "LoD Medium (Fir/Larch/Pine/Spruce)",
                    options: DTAPicklists.lodMediumFirLarchPineSpruceOptions,
                    selectedOption: $viewModel.lodMediumFirLarchPineSpruce
                )) {
                    HStack {
                        Text("LoD Medium (Fir/Larch/Pine/Spruce)")
                        Spacer()
                        Text(viewModel.lodMediumFirLarchPineSpruce.isEmpty ? "Select..." : viewModel.lodMediumFirLarchPineSpruce)
                            .foregroundColor(.secondary)
                    }
                }
                .disabled(viewModel.levelOfDisturbance == "VLR" || viewModel.levelOfDisturbance == "Low" || viewModel.levelOfDisturbance == "High")
                .foregroundColor(viewModel.lodMediumFirLarchPineSpruce.isEmpty && !["VLR", "Low", "High"].contains(viewModel.levelOfDisturbance) ? .primary : .green)

                NavigationLink(destination: SingleSelectPickerView(
                    title: "LoD Medium (Red/Yellow Cedar)",
                    options: DTAPicklists.lodMediumRedYellowCedarOptions,
                    selectedOption: $viewModel.lodMediumRedYellowCedar
                )) {
                    HStack {
                        Text("LoD Medium (Red/Yellow Cedar)")
                        Spacer()
                        Text(viewModel.lodMediumRedYellowCedar.isEmpty ? "Select..." : viewModel.lodMediumRedYellowCedar)
                            .foregroundColor(.secondary)
                    }
                }
                .disabled(viewModel.levelOfDisturbance == "VLR" || viewModel.levelOfDisturbance == "Low" || viewModel.levelOfDisturbance == "High")
                .foregroundColor(viewModel.lodMediumRedYellowCedar.isEmpty && !["VLR", "Low", "High"].contains(viewModel.levelOfDisturbance) ? .primary : .green)
            }
        }
    }
    
    private var lodLowHazardsSummary: String {
        if viewModel.report.lodLowHazards == "Not Applicable" {
            return "Not Applicable"
        }
        if viewModel.lodLowHazardsSet.isEmpty {
            return "Select..."
        }
        if viewModel.lodLowHazardsSet.count > 2 {
            return "\(viewModel.lodLowHazardsSet.count) selected"
        }
        return viewModel.lodLowHazardsSet.sorted().joined(separator: ", ")
    }
    
    private var lodHighInfoBox: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("LOD High: S = Safe").font(.headline).bold()
            Text("If a tree is one of the following:")
            VStack(alignment: .leading, spacing: 4) {
                Text("  • class 1 tree (all species)")
                Text("  • class 2 trees with NO structural defects (all species) usually wind- or snow-snapped green trees, very light fire scorching).")
                Text("  • class 2 cedars with LOW failure potential defects (refer to table at right)")
                Text("  • class 3 conifers with NO structural defects (tree recently killed by insects, climate or light intensity fire— these will have no structural damage or decay)")
            }.padding(.leading, 10)
            Text("D = Dangerous : all other trees").bold()
            Text("(fall tree; create a no-work zone; or remove hazardous parts).").italic()
        }
        .font(.caption)
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(8)
    }
}



===== ./PivotPointV3/Binding+Extensions.swift =====
import SwiftUI

extension Binding {
    /// Safely unwraps an optional Binding for UI controls, providing a default value.
    /// This allows binding optional model properties to UI that requires a non-optional value.
    func unwrapped<T>(with defaultValue: T) -> Binding<T> where Value == T? {
        Binding<T>(
            get: { self.wrappedValue ?? defaultValue },
            set: { self.wrappedValue = $0 }
        )
    }
}



===== ./PivotPointV3/WaypointsDisplayView.swift =====
import SwiftUI
import CoreData
import CoreLocation

struct WaypointsDisplayView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @ObservedObject var report: DTAReport
    @StateObject private var locationHelper = LocationHelper.shared
    @State private var isShowingSpotSheet = false

    private var waypoints: [DTAWaypoint] {
        (report.waypoints as? Set<DTAWaypoint> ?? []).sorted { $0.label ?? "" < $1.label ?? "" }
    }
    
    private var hasStartPoint: Bool {
        waypoints.contains { $0.isStartPoint }
    }
    
    private var hasEndPoint: Bool {
        waypoints.contains { $0.isEndPoint }
    }

    var body: some View {
        Section("Assessment Waypoints") {
            HStack {
                Button("Add Start") {
                    addWaypoint(label: "Start", isStart: true)
                }
                .buttonStyle(.borderedProminent)
                .tint(.green)
                .disabled(hasStartPoint)
                
                Button("Add End") {
                    addWaypoint(label: "End", isEnd: true)
                }
                .buttonStyle(.borderedProminent)
                .tint(.red)
                .disabled(!hasStartPoint || hasEndPoint)
                
                Button("Add Spot") {
                    showSpotSheet()
                }
                .buttonStyle(.borderedProminent)
                .tint(.orange)
            }
            .frame(maxWidth: .infinity)

            ForEach(waypoints) { waypoint in
                HStack {
                    Text(waypoint.label ?? "Waypoint")
                        .fontWeight(.semibold)
                        .foregroundColor(colorForWaypoint(label: waypoint.label))
                    Spacer()
                    Text(waypoint.ddmCoordinateString)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .onDelete(perform: deleteWaypoint)
        }
        .sheet(isPresented: $isShowingSpotSheet) {
            SimpleSpotSheet(report: report, onDismiss: {
                isShowingSpotSheet = false
            })
        }
    }
    
    private func showSpotSheet() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            isShowingSpotSheet = true
        }
    }
    
    private func addWaypoint(label: String, isStart: Bool = false, isEnd: Bool = false) {
        let newWaypoint = DTAWaypoint(context: viewContext)
        newWaypoint.id = UUID()
        newWaypoint.label = label
        newWaypoint.latitude = locationHelper.currentLatitude
        newWaypoint.longitude = locationHelper.currentLongitude
        newWaypoint.isStartPoint = isStart
        newWaypoint.isEndPoint = isEnd
        newWaypoint.dtaReport = report
        save()
    }
    
    private func deleteWaypoint(at offsets: IndexSet) {
        for index in offsets {
            viewContext.delete(waypoints[index])
        }
        save()
    }

    private func save() {
        do {
            try viewContext.save()
        } catch {
            print("Failed to save waypoint: \(error)")
        }
    }
    
    private func colorForWaypoint(label: String?) -> Color {
        guard let label = label else { return .primary }
        if label.starts(with: "Start") { return .green }
        if label.starts(with: "End") { return .red }
        if label.starts(with: "Spot") { return .orange }
        return .primary
    }
}

// Simple spot waypoint sheet to avoid conflicts
struct SimpleSpotSheet: View {
    @ObservedObject var report: DTAReport
    @Environment(\.managedObjectContext) private var viewContext
    let onDismiss: () -> Void
    @State private var comment = ""

    var body: some View {
        NavigationView {
            Form {
                Section("Spot Details") {
                    TextField("Comment (e.g., spot fire, pump site)", text: $comment)
                }
            }
            .navigationTitle("Add Spot Waypoint")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        onDismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Add") {
                        addSpotWaypoint()
                    }
                }
            }
        }
    }
    
    private func addSpotWaypoint() {
        let spotCount = (report.waypoints as? Set<DTAWaypoint> ?? []).filter {
            $0.label?.starts(with: "Spot") == true
        }.count
        
        let newWaypoint = DTAWaypoint(context: viewContext)
        newWaypoint.id = UUID()
        newWaypoint.label = "Spot \(spotCount + 1)"
        newWaypoint.latitude = LocationHelper.shared.currentLatitude
        newWaypoint.longitude = LocationHelper.shared.currentLongitude
        newWaypoint.locationNotes = comment
        newWaypoint.isSpotPoint = true
        newWaypoint.dtaReport = report
        
        do {
            try viewContext.save()
        } catch {
            print("Failed to save spot waypoint: \(error)")
        }
        
        onDismiss()
    }
}



===== ./PivotPointV3/FooterView.swift =====
import SwiftUI

/// Footer view displayed at the bottom of the app
struct FooterView: View {
    var body: some View {
        Text("PRAEMONITUS PRAEMUNITUS")
            .font(.footnote)
            .fontWeight(.semibold)
            .foregroundColor(.secondary)
            // Reduced padding for a tighter layout
            .padding(.vertical, 4)
            .frame(maxWidth: .infinity)
            .background(Color(.systemGroupedBackground).opacity(0.8))
    }
}



===== ./PivotPointV3/MainMenuView.swift =====
import SwiftUI
import PhotosUI
import CoreData

struct MainMenuView: View {
    @EnvironmentObject var userSettings: UserSettings
    @Environment(\.managedObjectContext) private var viewContext
    
    @State private var selectedWatermark: UIImage? = nil
    @State private var showPhotoPicker = false
    @State private var selectedItem: PhotosPickerItem? = nil
    @State private var showUserInfoEditor = false
    @State private var showMoreOptions = false

    var body: some View {
        NavigationStack {
            ZStack {
                // MARK: - Layer 1: Watermark
                GeometryReader { geometry in
                    let watermarkImage = selectedWatermark ?? UIImage(named: "NewAppLogo")
                    
                    if let uiImage = watermarkImage {
                        Image(uiImage: uiImage)
                            .resizable()
                            .scaledToFit()
                            .frame(width: geometry.size.width * 0.8)
                            .opacity(0.9)
                            .shadow(color: .white.opacity(0.6), radius: 20)
                            .shadow(color: .orange.opacity(0.3), radius: 40)
                            .shadow(color: .red.opacity(0.2), radius: 10)
                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                            .onLongPressGesture(minimumDuration: 3) { showPhotoPicker = true }
                            .onTapGesture(count: 2) { selectedWatermark = nil }
                    }
                }
                
                // MARK: - Layer 2: Main UI Content
                VStack(spacing: 0) {
                    HeaderView()
                    
                    Spacer()
                    
                    ProfileStatusView()
                        .padding(.bottom, 4)
                    
                    // MARK: - Bottom Footer Menu
                    HStack {
                        // FIXED: All buttons now use a consistent structure.
                        NavigationLink(value: "FireCenterListView") {
                            HoverButtonView(systemImageName: "flame.circle", label: "Fire Logs")
                        }
                        .buttonStyle(PlainButtonStyle())
                        
                        NavigationLink(value: "ReferencesView") {
                            HoverButtonView(systemImageName: "books.vertical", label: "References")
                        }
                        .buttonStyle(PlainButtonStyle())
                        
                        NavigationLink(value: "CertificationView") {
                            HoverButtonView(systemImageName: "checkmark.seal", label: "Certs")
                        }
                        .buttonStyle(PlainButtonStyle())

                        NavigationLink(value: "ExportView") {
                            HoverButtonView(systemImageName: "square.and.arrow.up", label: "Export")
                        }
                        .buttonStyle(PlainButtonStyle())
                        
                        Button(action: { showMoreOptions = true }) {
                            HoverButtonView(systemImageName: "ellipsis.circle", label: "More")
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                    .background(Color(.systemGroupedBackground))
                }
            }
            .sheet(isPresented: $showUserInfoEditor) { UserInfoEntryView().environmentObject(userSettings) }
            .confirmationDialog("More Options", isPresented: $showMoreOptions) {
                Button("Edit User Profile") { showUserInfoEditor = true }
                Button("Cancel", role: .cancel) {}
            }
            .photosPicker(isPresented: $showPhotoPicker, selection: $selectedItem)
            .onChange(of: selectedItem) { _, newItem in
                Task {
                    if let item = newItem, let data = try? await item.loadTransferable(type: Data.self), let image = UIImage(data: data) {
                        selectedWatermark = image
                    }
                }
            }
            .navigationDestination(for: String.self) { value in
                switch value {
                case "FireCenterListView":
                    FireCenterListView()
                case "ReferencesView":
                    ReferencesView()
                case "CertificationView":
                    CertificationView()
                case "ExportView":
                    ExportView()
                default:
                    EmptyView()
                }
            }
            .navigationDestination(for: FireFolder.self) { folder in
                FireFolderDetailView(fireFolder: folder)
            }
            .navigationDestination(for: DTAReport.self) { report in
                DTAReportView(viewModel: DTAReportViewModel(report: report, parentContext: viewContext, userSettings: userSettings))
            }
        }
    }
}

// ProfileStatusView remains unchanged
struct ProfileStatusView: View {
    @EnvironmentObject var userSettings: UserSettings
    
    var body: some View {
        Text(formattedUserInfo())
            .font(.subheadline)
            .foregroundColor(.secondary)
            .lineLimit(1)
            .truncationMode(.tail)
            .padding(.horizontal)
            .padding(.vertical, 5)
            .background(.thinMaterial, in: Capsule())
            .padding(.bottom, 8)
    }
    
    private func formattedUserInfo() -> String {
        var parts: [String] = []
        if !userSettings.userName.isEmpty { parts.append(userSettings.userName) }
        if !userSettings.callSign.isEmpty { parts.append(userSettings.callSign) }
        if !userSettings.crewName.isEmpty { parts.append(userSettings.crewName) }
        
        return parts.isEmpty ? "No Profile Set" : parts.joined(separator: " • ")
    }
}



===== ./PivotPointV3/AddSpotWaypointView.swift =====
import SwiftUI
import CoreData
import PhotosUI

struct AddSpotWaypointView: View {
    @ObservedObject var report: DTAReport
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    @State private var comment = ""
    @State private var spotPhotoPickerItem: PhotosPickerItem?
    @State private var showingCamera = false
    @State private var attachedPhotoData: Data?
    @State private var showCameraUnavailableAlert = false

    var body: some View {
        NavigationView {
            Form {
                Section("Spot Details") {
                    TextField("Comment (e.g., spot fire, pump site)", text: $comment)
                }
                
                Section("Attach Photo (Optional)") {
                    if let data = attachedPhotoData, let uiImage = UIImage(data: data) {
                        Image(uiImage: uiImage).resizable().scaledToFit().frame(maxHeight: 200).cornerRadius(8)
                        Button("Remove Photo", role: .destructive) { attachedPhotoData = nil }
                    } else {
                        Button("Take Photo") {
                            if UIImagePickerController.isSourceTypeAvailable(.camera) {
                                showingCamera = true
                            } else {
                                showCameraUnavailableAlert = true
                            }
                        }
                        PhotosPicker("Choose from Library", selection: $spotPhotoPickerItem, matching: .images)
                    }
                }
            }
            .navigationTitle("Add Spot Waypoint")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) { Button("Cancel") { dismiss() } }
                ToolbarItem(placement: .confirmationAction) { Button("Add") { addSpotAndDismiss() } }
            }
            .fullScreenCover(isPresented: $showingCamera) {
                ImagePicker(sourceType: .camera) { self.attachedPhotoData = $0 }
            }
            .onChange(of: spotPhotoPickerItem) { _, newItem in
                Task {
                    if let data = try? await newItem?.loadTransferable(type: Data.self) {
                        self.attachedPhotoData = data
                    }
                }
            }
            .alert("Camera Not Available", isPresented: $showCameraUnavailableAlert) {
                Button("OK") {}
            } message: {
                Text("This device does not have a camera available.")
            }
        }
    }
    
    private func addSpotAndDismiss() {
        let spotLabel = "Spot \(report.waypointsArray.filter { $0.isSpotPoint }.count + 1)"
        
        let newWaypoint = DTAWaypoint(context: viewContext)
        newWaypoint.latitude = LocationHelper.shared.currentLatitude
        newWaypoint.longitude = LocationHelper.shared.currentLongitude
        newWaypoint.label = spotLabel
        newWaypoint.locationNotes = comment
        newWaypoint.isSpotPoint = true
        newWaypoint.dtaReport = report
        
        if let data = attachedPhotoData {
            let attachment = MediaAttachment(context: viewContext)
            attachment.id = UUID()
            attachment.mediaType = "photo"
            attachment.photoTimestamp = Date()
            
            let sanitizedComment = sanitizeForFileName(comment)
            let finalFileName = sanitizedComment.isEmpty ? "\(spotLabel).jpg" : "\(spotLabel)-\(sanitizedComment).jpg"
            attachment.fileName = finalFileName
            
            if let docsUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
                let fileUrl = docsUrl.appendingPathComponent(finalFileName)
                do {
                    try data.write(to: fileUrl)
                    attachment.fileURL = fileUrl.absoluteString
                } catch {
                    print("Failed to write image data to disk: \(error)")
                }
            }
            attachment.dtaReport = report
        }
        
        try? viewContext.save()
        dismiss()
    }
    
    private func sanitizeForFileName(_ string: String) -> String {
        let invalidCharacters = CharacterSet(charactersIn: "/\\?%*|\"<>: ")
        return string.components(separatedBy: invalidCharacters).joined(separator: "_")
    }
}



===== ./PivotPointV3/EditWaypointView.swift =====
import SwiftUI
import CoreData

struct EditWaypointView: View {
    @ObservedObject var waypoint: DTAWaypoint
    @Environment(\.managedObjectContext) private var viewContext
    
    var body: some View {
        Form {
            Section("Edit Waypoint Notes") {
                TextEditor(text: Binding(
                    get: { waypoint.locationNotes ?? "" },
                    set: { waypoint.locationNotes = $0 }
                ))
                .frame(height: 200)
            }
        }
        .navigationTitle(waypoint.label ?? "Edit Waypoint")
        .navigationBarTitleDisplayMode(.inline)
        .onDisappear {
            // Auto-save any changes when the user navigates back
            if viewContext.hasChanges {
                do {
                    try viewContext.save()
                } catch {
                    print("Failed to save waypoint edits: \(error.localizedDescription)")
                }
            }
        }
    }
}



===== ./PivotPointV3/DailyAssessmentSectionView.swift =====
import SwiftUI

struct DailyAssessmentSectionView: View {
    @ObservedObject var viewModel: DTAReportViewModel
    @State private var showCrewBriefingAlert = false
    
    var body: some View {
        Section("Daily Assessment") {
            NavigationLink(destination: SingleSelectPickerView(
                title: "SAO Overview",
                options: DTAPicklists.saoOverviewOptions,
                selectedOption: $viewModel.saoOverview
            )) {
                HStack {
                    Text("SAO Overview")
                    Spacer()
                    Text(viewModel.saoOverview.isEmpty ? "Select..." : viewModel.saoOverview)
                        .foregroundColor(.secondary)
                }
            }
            .foregroundColor(viewModel.saoOverview.isEmpty ? .primary : .green)
            
            if !viewModel.saoOverview.isEmpty {
                // Only show comment box if SAO is "No"
                if viewModel.saoOverview == "No" {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Explain why SAO wasn't completed:")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        TextEditor(text: $viewModel.saoComment)
                            .frame(height: 80)
                            .overlay(RoundedRectangle(cornerRadius: 8).stroke(Color.gray.opacity(0.3), lineWidth: 1))
                    }
                }
                
                Toggle("SAO Briefed to Crew", isOn: $viewModel.saoBriefedToCrew)
                    .foregroundColor(viewModel.saoBriefedToCrew ? .green : .primary)
                    .onChange(of: viewModel.saoBriefedToCrew) { _, briefed in
                        if !briefed {
                            showCrewBriefingAlert = true
                        }
                    }
                    .alert("Crew Briefing Required", isPresented: $showCrewBriefingAlert) {
                        Button("OK, I'll brief the crew", role: .cancel) {}
                    } message: {
                        Text("Please ensure you brief the SAO to your crew before proceeding with work.")
                    }
            }
            
            NavigationLink(destination: MultiSelectPickerView(
                title: "Primary Hazards Present",
                options: DTAPicklists.primaryHazardsPresentOptions,
                selection: $viewModel.primaryHazardsPresent
            )) {
                HStack {
                    Text("Primary Hazards Present")
                    Spacer()
                    Text(primaryHazardsSummary)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.trailing)
                }
            }
            .foregroundColor(viewModel.primaryHazardsPresent.isEmpty ? .primary : .green)
            
            NavigationLink(destination: SingleSelectPickerViewNoAutoDismiss(
                title: "Activity",
                options: DTAPicklists.activityOptions,
                selectedOption: $viewModel.activity
            )) {
                HStack {
                    Text("Activity")
                    Spacer()
                    Text(activitySummary)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.trailing)
                }
            }
            .foregroundColor(viewModel.activity.isEmpty ? .primary : .green)
        }
    }
    
    private var primaryHazardsSummary: String {
        if viewModel.primaryHazardsPresent.isEmpty { return "Select..." }
        if viewModel.primaryHazardsPresent.count > 2 { return "\(viewModel.primaryHazardsPresent.count) selected" }
        return viewModel.primaryHazardsPresent.sorted().joined(separator: ", ")
    }
    
    private var activitySummary: String {
        if viewModel.activity.isEmpty { return "Select..." }
        return viewModel.activity
    }
}

// New picker view that doesn't auto-dismiss
struct SingleSelectPickerViewNoAutoDismiss: View {
    let title: String
    let options: [String]
    @Binding var selectedOption: String

    var body: some View {
        List(options, id: \.self) { option in
            Button(action: {
                selectedOption = option
            }) {
                HStack {
                    Text(option)
                    Spacer()
                    if selectedOption == option {
                        Image(systemName: "checkmark")
                            .foregroundColor(.accentColor)
                    }
                }
            }
            .buttonStyle(PressedHighlightButtonStyle())
            .foregroundColor(.primary)
            .listRowBackground(selectedOption == option ? Color.accentColor.opacity(0.35) : Color(uiColor: .systemBackground))
        }
        .navigationTitle(title)
        .navigationBarTitleDisplayMode(.inline)
    }
}



===== ./PivotPointV3/CommentsSectionView.swift =====
import SwiftUI

struct CommentsSectionView: View {
    @Binding var comments: String
    
    var body: some View {
        Section("Additional Comments") {
            TextEditor(text: $comments)
                .frame(height: 150)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(comments.isEmpty ? Color.gray : Color.green, lineWidth: 1)
                )
                .keyboardToolbar()
        }
    }
}



===== ./PivotPointV3/KeyboardToolbar.swift =====
import SwiftUI

extension View {
    func keyboardToolbar() -> some View {
        self.toolbar {
            ToolbarItemGroup(placement: .keyboard) {
                Spacer()
                Button("Done") {
                    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
                }
            }
        }
    }
}



===== ./PivotPointV3/SAOSectionView.swift =====
import SwiftUI

struct SAOSectionView: View {
    @ObservedObject var report: DTAReport
    
    var body: some View {
        Section("SAO (Safety Assessment Overview)") {
            VStack(alignment: .leading, spacing: 4) {
                Text("SAO Overview").font(.caption).foregroundColor(.secondary)
                TextField("Enter SAO overview", text: $report.saoOverview.unwrapped(with: ""), axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
            }
            
            Toggle("SAO Briefed to Crew", isOn: $report.saoBriefedToCrew)
            
            VStack(alignment: .leading, spacing: 4) {
                Text("SAO Comment").font(.caption).foregroundColor(.secondary)
                TextField("Enter SAO comment", text: $report.saoComment.unwrapped(with: ""), axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Area Safe for Work Comment").font(.caption).foregroundColor(.secondary)
                TextField("Enter area safety comment", text: $report.areaSafeForWorkComment.unwrapped(with: ""), axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
            }
            
            Toggle("Area Between Points Safe for Work", isOn: $report.areaBetweenPointsSafeForWork)
        }
    }
}



===== ./PivotPointV3/EditFireFolderView.swift =====
import SwiftUI

struct EditFireFolderView: View {
    @ObservedObject var fireFolder: FireFolder
    @Environment(\.dismiss) private var dismiss
    
    @State private var fireNumber: String
    
    init(fireFolder: FireFolder) {
        self.fireFolder = fireFolder
        _fireNumber = State(initialValue: fireFolder.fireNumber ?? "")
    }

    var body: some View {
        NavigationView {
            Form {
                Section("Edit Fire Number") {
                    TextField("Fire Number", text: $fireNumber)
                }
            }
            .navigationTitle("Edit Fire")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") { saveAndDismiss() }
                        .disabled(fireNumber.isEmpty)
                }
            }
        }
    }
    
    private func saveAndDismiss() {
        fireFolder.fireNumber = fireNumber
        fireFolder.folderName = "Fire \(fireNumber)"
        
        do {
            try fireFolder.managedObjectContext?.save()
            dismiss()
        } catch {
            print("Failed to save edited fire folder: \(error)")
        }
    }
}



===== ./PivotPointV3/PhotosSectionView.swift =====
import SwiftUI
import PhotosUI
import CoreData

struct PhotosSectionView: View {
    @ObservedObject var viewModel: DTAReportViewModel
    @State private var selectedPhotos: [PhotosPickerItem] = []
    
    var body: some View {
        Section("Media Attachments") {
            // Use the mediaAttachmentsArray from DTAReport extension
            ForEach(viewModel.report.mediaAttachmentsArray, id: \.objectID) { media in
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(media.fileName ?? "Media File")
                            .font(.headline)
                        
                        if let mediaType = media.mediaType {
                            Text(mediaType)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        if let photoDate = media.photoDate {
                            Text(photoDate, style: .date)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        if let locationDDM = media.photoLocationDDM, !locationDDM.isEmpty {
                            Text("Location: \(locationDDM)")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    }
                    
                    Spacer()
                    
                    Button("Delete") {
                        viewModel.removeMediaAttachment(media)
                    }
                    .foregroundColor(.red)
                }
                .padding(.vertical, 4)
            }
            
            PhotosPicker(
                selection: $selectedPhotos,
                maxSelectionCount: 10,
                matching: .images
            ) {
                HStack {
                    Image(systemName: "plus.circle")
                    Text("Add Photos")
                }
            }
            .onChange(of: selectedPhotos) { _, newPhotos in
                Task {
                    for photo in newPhotos {
                        if let data = try? await photo.loadTransferable(type: Data.self) {
                            await MainActor.run {
                                let attachment = MediaAttachment(context: viewModel.context)
                                attachment.id = UUID()
                                attachment.mediaType = "photo"
                                attachment.photoTimestamp = Date()
                                attachment.dtaReport = viewModel.report
                                attachment.fileName = "Photo_\(Date().timeIntervalSince1970).jpg"
                                
                                if let docsUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
                                    let fileUrl = docsUrl.appendingPathComponent(attachment.fileName!)
                                    do {
                                        try data.write(to: fileUrl)
                                        attachment.fileURL = fileUrl.absoluteString
                                    } catch {
                                        print("Failed to write image data: \(error)")
                                    }
                                }
                                viewModel.saveContext()
                            }
                        }
                    }
                    selectedPhotos.removeAll()
                }
            }
        }
    }
}



===== ./PivotPointV3/MenuButton.swift =====
import SwiftUI

/// A stylized button used in menus with an icon and title
struct MenuButton: View {
    let title: String
    let icon: String

    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(.white)
                .imageScale(.large)

            Text(title)
                .font(.headline)
                .foregroundColor(.white)

            Spacer()
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.accentColor)
        .cornerRadius(12)
        .shadow(radius: 3)
        .padding(.horizontal)
    }
}



===== ./PivotPointV3/DTAReportExporter.swift =====
import Foundation
import UIKit
import PDFKit

class DTAReportExporter {
    
    // MARK: - KML EXPORT
    func generateKML(for report: DTAReport) -> String {
        let reportData = getFullReportData(report: report)
        let dataHtml = reportData.map { "<b>\($0.label):</b> \($0.value)" }.joined(separator: "<br>")
        
        var kml = """
        <?xml version="1.0" encoding="UTF-8"?>
        <kml xmlns="http://www.opengis.net/kml/2.2">
          <Document>
            <name>\(sanitizeXMLString(report.reportTitle ?? "DTA Report"))</name>
        """
        
        for waypoint in report.waypointsArray {
            let waypointName = "\(waypoint.label ?? "Waypoint")"
            var description = """
            <b>\(sanitizeXMLString(waypointName))</b><br>
            Coords: \(waypoint.ddmCoordinateString)<br>
            Notes: \(sanitizeXMLString(waypoint.locationNotes ?? "N/A"))<br>
            """
            
            if let photoData = findPhotoData(for: waypoint, report: report) {
                let base64String = photoData.base64EncodedString()
                description += "<br><img src='data:image/jpeg;base64,\(base64String)' width='300' />"
            }
            
            kml += """
              <Placemark>
                <name>\(sanitizeXMLString(waypointName))</name>
                <description><![CDATA[\(description)]]></description>
                <Point>
                  <coordinates>\(waypoint.longitude),\(waypoint.latitude),0</coordinates>
                </Point>
              </Placemark>
            """
        }
        
        if let firstWaypoint = report.waypointsArray.first {
            var fullReportDescription = "<h1>Full Report Details</h1><p>\(dataHtml)</p>"
            for attachment in report.mediaAttachmentsArray {
                if let data = findData(for: attachment) {
                    let base64String = data.base64EncodedString()
                    fullReportDescription += "<h3>\(attachment.fileName ?? "Photo")</h3><br><img src='data:image/jpeg;base64,\(base64String)' width='300' />"
                }
            }
            
            kml += """
              <Placemark>
                <name>Full DTA Report</name>
                <description><![CDATA[\(fullReportDescription)]]></description>
                <Point>
                  <coordinates>\(firstWaypoint.longitude),\(firstWaypoint.latitude),0</coordinates>
                </Point>
              </Placemark>
            """
        }
        
        kml += "</Document></kml>"
        return kml
    }

    // MARK: - CSV EXPORT
    func generateCSV(for report: DTAReport) -> String {
        let reportData = getFullReportData(report: report)
        
        var csv = "\"Pivot Point: Practical Forestry Solutions\"\n"
        csv += "\"DTA Report - \(sanitizeCSVString(report.reportTitle ?? ""))\"\n\n"
        
        var currentCategory = ""
        for item in reportData {
            if item.category != currentCategory {
                csv += "\n\"**\(item.category.uppercased())**\",\n"
                currentCategory = item.category
            }
            csv += "\"\(sanitizeCSVString(item.label))\",\"\(sanitizeCSVString(item.value))\"\n"
        }
        
        csv += "\n\"**WAYPOINTS**\",\n"
        csv += "\"Label\",\"Coordinates\",\"Notes\",\"Photo Filename\"\n"
        for waypoint in report.waypointsArray {
            let photoFile = findPhoto(for: waypoint, report: report)?.fileName ?? ""
            csv += "\"\(sanitizeCSVString(waypoint.label ?? ""))\",\"\(waypoint.ddmCoordinateString)\",\"\(sanitizeCSVString(waypoint.locationNotes ?? ""))\",\"\(photoFile)\"\n"
        }
        
        return csv
    }

    // MARK: - PDF EXPORT
    func generatePDF(for report: DTAReport) -> Data {
        let reportData = getFullReportData(report: report)
        let pdfMetaData = [kCGPDFContextCreator: "Pivot Point"]
        let format = UIGraphicsPDFRendererFormat()
        format.documentInfo = pdfMetaData as [String: Any]

        let pageSize = CGRect(x: 0, y: 0, width: 612, height: 792)
        let renderer = UIGraphicsPDFRenderer(bounds: pageSize, format: format)

        let data = renderer.pdfData { (context) in
            context.beginPage()
            var currentY: CGFloat = 30
            let margin: CGFloat = 40
            let contentWidth = pageSize.width - 2 * margin
            
            if let headerImage = UIImage(named: "HeaderDark") {
                let imageWidth: CGFloat = 150
                let imageHeight = (imageWidth / headerImage.size.width) * headerImage.size.height
                let imageRect = CGRect(x: (pageSize.width - imageWidth) / 2, y: currentY, width: imageWidth, height: imageHeight)
                headerImage.draw(in: imageRect)
                currentY += imageHeight + 10
            }
            
            var currentCategory = ""
            for item in reportData {
                if currentY > 720 { context.beginPage(); currentY = margin }
                
                if item.category != currentCategory {
                    currentY += 10
                    currentY = drawPDFText(text: item.category.uppercased(), at: currentY, on: context.cgContext, width: contentWidth, margin: margin, font: .boldSystemFont(ofSize: 14))
                    currentCategory = item.category
                }
                currentY = drawPDFText(text: "\(item.label): \(item.value)", at: currentY, on: context.cgContext, width: contentWidth - 10, margin: margin + 10)
            }
            
            if !report.mediaAttachmentsArray.isEmpty {
                 if currentY > 600 { context.beginPage(); currentY = margin }
                currentY += 10
                currentY = drawPDFText(text: "ATTACHED PHOTOS", at: currentY, on: context.cgContext, width: contentWidth, margin: margin, font: .boldSystemFont(ofSize: 14))
                
                for attachment in report.mediaAttachmentsArray {
                    if let data = findData(for: attachment), let image = UIImage(data: data) {
                        let availableHeight = 792 - currentY - margin
                        let imageAspectRatio = image.size.width / image.size.height
                        let displayWidth = contentWidth
                        let displayHeight = displayWidth / imageAspectRatio
                        
                        if displayHeight > availableHeight {
                            context.beginPage()
                            currentY = margin
                        }
                        
                        let imageRect = CGRect(x: margin, y: currentY, width: displayWidth, height: displayHeight)
                        image.draw(in: imageRect)
                        currentY += displayHeight + 5
                        currentY = drawPDFText(text: attachment.fileName ?? "Photo", at: currentY, on: context.cgContext, width: contentWidth, margin: margin, font: .systemFont(ofSize: 10))
                        currentY += 10
                    }
                }
            }
        }
        return data
    }
    
    // MARK: - Private Helpers
    private func getFullReportData(report: DTAReport) -> [(category: String, label: String, value: String)] {
        // FIXED: Declared as an array of NAMED tuples
        var data: [(category: String, label: String, value: String)] = []
        let na = "N/A"

        // FIXED: Appending NAMED tuples
        data.append((category: "Metadata", label: "Report Title", value: report.reportTitle ?? na))
        data.append((category: "Metadata", label: "Fire Number", value: report.fireNumber ?? na))
        data.append((category: "Metadata", label: "Fire Center", value: report.fireCenter ?? na))
        data.append((category: "Metadata", label: "Assessed By", value: report.assessedBy ?? na))
        data.append((category: "Metadata", label: "DTF Completed By", value: report.dtfCompletedBy ?? na))
        data.append((category: "Metadata", label: "Assessment Date", value: formatDateForPDF(report.manualDateTime ?? Date())))
        
        data.append((category: "Daily Assessment", label: "SAO Overview", value: report.saoOverview ?? na))
        data.append((category: "Daily Assessment", label: "SAO Briefed to Crew", value: report.saoBriefedToCrew ? "Yes" : "No"))
        if !report.saoComment.isNilOrEmpty { data.append((category: "Daily Assessment", label: "SAO Comments", value: report.saoComment!)) }
        data.append((category: "Daily Assessment", label: "Primary Hazards Present", value: report.primaryHazardsPresent ?? na))
        data.append((category: "Daily Assessment", label: "Activity", value: report.activity ?? na))
        
        data.append((category: "Level of Disturbance", label: "Level of Disturbance", value: report.levelOfDisturbance ?? na))
        data.append((category: "Level of Disturbance", label: "LoD Low Hazards", value: report.lodLowHazards ?? na))
        data.append((category: "Level of Disturbance", label: "LoD Medium (Fir/Larch/Pine/Spruce)", value: report.lodMediumFirLarchPineSpruce ?? na))
        data.append((category: "Level of Disturbance", label: "LoD Medium (Red/Yellow Cedar)", value: report.lodMediumRedYellowCedar ?? na))
        
        let fuelTypes = report.fuelTypes as? Set<FuelTypeSelection> ?? []
        for fuelType in fuelTypes.sorted(by: { $0.fuelType ?? "" < $1.fuelType ?? "" }) {
            data.append((category: "Fuel Types", label: fuelType.fuelType ?? "Unknown", value: "\(fuelType.percentage)%"))
        }

        data.append((category: "Assessment Protocol", label: "DTA Marking Protocol Followed", value: report.dtaMarkingProtocolFollowed ?? na))
        if !report.dtaMarkingProtocolComment.isNilOrEmpty { data.append((category: "Assessment Protocol", label: "DTA Protocol Comment", value: report.dtaMarkingProtocolComment!)) }
        data.append((category: "Assessment Protocol", label: "Estimated Trees Felled", value: "\(report.estimatedTreesFelled)"))
        data.append((category: "Assessment Protocol", label: "No Work Zones Present", value: report.noWorkZonesPresent ?? na))
        data.append((category: "Assessment Protocol", label: "No Work Zones Identified & Communicated", value: report.noWorkZones ? "Yes" : "No"))
        data.append((category: "Assessment Protocol", label: "Assessed min. 1.5 TL from work area", value: report.assessedMin1_5TreeLengths ?? na))
        if !report.assessedTLComment.isNilOrEmpty { data.append((category: "Assessment Protocol", label: "1.5 TL Comment", value: report.assessedTLComment!)) }
        data.append((category: "Assessment Protocol", label: "Distance from Work Area", value: report.assessedDistanceFromWorkArea ?? na))
        data.append((category: "Assessment Protocol", label: "Area between start and end safe for work", value: report.areaBetweenPointsSafeForWork ? "Yes" : "No"))
        if !report.areaSafeForWorkComment.isNilOrEmpty { data.append((category: "Assessment Protocol", label: "Area Safety Comment", value: report.areaSafeForWorkComment!)) }
        data.append((category: "Assessment Protocol", label: "Reassessment Needed", value: report.reassessmentNeeded ?? na))
        
        if !report.comments.isNilOrEmpty { data.append((category: "Comments", label: "Additional Comments", value: report.comments!)) }
        
        // The filter now works correctly because the elements have a '.value' member.
        return data.filter { !$0.value.isEmpty && $0.value != na }
    }

    private func findPhoto(for waypoint: DTAWaypoint, report: DTAReport) -> MediaAttachment? {
        guard waypoint.isSpotPoint else { return nil }
        
        let spotLabel = sanitizeForFileName(waypoint.label ?? "Spot")
        let notes = sanitizeForFileName(waypoint.locationNotes ?? "")
        let expectedFileName = notes.isEmpty ? "\(spotLabel).jpg" : "\(spotLabel)-\(notes).jpg"

        return report.mediaAttachmentsArray.first { $0.fileName == expectedFileName }
    }
    
    private func sanitizeForFileName(_ string: String) -> String {
        let invalidCharacters = CharacterSet(charactersIn: "/\\?%*|\"<>: ")
        return string.components(separatedBy: invalidCharacters).joined(separator: "_")
    }

    private func findPhotoData(for waypoint: DTAWaypoint, report: DTAReport) -> Data? {
        guard let attachment = findPhoto(for: waypoint, report: report) else { return nil }
        return findData(for: attachment)
    }
    
    private func findData(for attachment: MediaAttachment) -> Data? {
        guard let fileName = attachment.fileName, let docsUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return nil }
        let fileUrl = docsUrl.appendingPathComponent(fileName)
        return try? Data(contentsOf: fileUrl)
    }

    private func drawPDFText(text: String, at y: CGFloat, on context: CGContext, width: CGFloat, margin: CGFloat, font: UIFont = .systemFont(ofSize: 11), color: UIColor = .black) -> CGFloat {
        let attributedString = NSAttributedString(string: text, attributes: [.font: font, .foregroundColor: color])
        let size = attributedString.boundingRect(with: CGSize(width: width, height: .greatestFiniteMagnitude), options: .usesLineFragmentOrigin, context: nil)
        attributedString.draw(in: CGRect(x: margin, y: y, width: width, height: size.height))
        return y + size.height + 4
    }
    
    private func sanitizeXMLString(_ input: String) -> String {
        var sanitized = input
        sanitized = sanitized.replacingOccurrences(of: "&", with: "&amp;")
        sanitized = sanitized.replacingOccurrences(of: "<", with: "&lt;")
        sanitized = sanitized.replacingOccurrences(of: ">", with: "&gt;")
        sanitized = sanitized.replacingOccurrences(of: "\"", with: "&quot;")
        sanitized = sanitized.replacingOccurrences(of: "'", with: "&apos;")
        return sanitized
    }

    private func sanitizeCSVString(_ input: String) -> String {
        let needsQuotes = input.contains(",") || input.contains("\n") || input.contains("\"")
        var sanitized = input.replacingOccurrences(of: "\"", with: "\"\"")
        if needsQuotes {
            sanitized = "\"\(sanitized)\""
        }
        return sanitized
    }
    
    private func formatDateForPDF(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm"
        return formatter.string(from: date)
    }
}

extension Optional where Wrapped == String {
    var isNilOrEmpty: Bool {
        return self?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true
    }
}



===== ./PivotPointV3/MultiSelectPicker.swift =====
import SwiftUI

struct MultiSelectPicker: View {
    let title: String
    let options: [String]
    @Binding var selection: Set<String>

    var body: some View {
        NavigationLink(destination: MultiSelectPickerView(title: title, options: options, selection: $selection)) {
            HStack {
                Text(title)
                Spacer()
                Text(selectedOptionsText)
                     .foregroundColor(selection.isEmpty ? .secondary : .primary)
                    .multilineTextAlignment(.trailing)
            }
        }
    }

    private var selectedOptionsText: String {
        if selection.isEmpty { return "Select..." }
        if selection.count > 2 { return "\(selection.count) selected" }
        return selection.sorted().joined(separator: ", ")
    }
}

struct MultiSelectPickerView: View {
    let title: String
    let options: [String]
    @Binding var selection: Set<String>

    var body: some View {
        List(options, id: \.self) { option in
            Button(action: {
                if selection.contains(option) {
                    selection.remove(option)
                } else {
                    selection.insert(option)
                }
            }) {
                HStack {
                    Text(option).foregroundColor(.primary)
                    Spacer()
                    if selection.contains(option) {
                        Image(systemName: "checkmark").foregroundColor(.accentColor)
                    }
                }
            }
        }
        .navigationTitle(title)
    }
}



===== ./PivotPointV3/assessmentStartEndSpot.swift =====
import SwiftUI
import CoreData
import MapKit

struct AssessmentStartEndSpotView: View {
    @ObservedObject var report: DTAReport
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    @State private var locationNotes: String = ""
    @State private var isStopPoint: Bool = false
    
    var body: some View {
        Form {
            Section("Waypoint Info") {
                TextField("Notes / Label", text: $locationNotes)
                
                Toggle("Mark as Stop Point?", isOn: $isStopPoint)
            }
            
            Section {
                Button(action: addWaypoint) {
                    Text("Add Waypoint")
                        .frame(maxWidth: .infinity, alignment: .center)
                }
            }
        }
        .navigationTitle("Add Waypoint")
    }
    
    private func addWaypoint() {
        let newWaypoint = DTAWaypoint(context: viewContext)
        newWaypoint.id = UUID()
        newWaypoint.latitude = LocationHelper.shared.currentLatitude
        newWaypoint.longitude = LocationHelper.shared.currentLongitude
        newWaypoint.locationNotes = locationNotes
        newWaypoint.isStopPoint = isStopPoint
        newWaypoint.dtaReport = report  // Changed from 'report' to 'dtaReport'
        
        do {
            try viewContext.save()
            dismiss()
        } catch {
            print("Failed to save waypoint: \(error.localizedDescription)")
        }
    }
}



===== ./PivotPointV3/EnhancedAddSpotWaypointView.swift =====
import SwiftUI
import CoreData
import PhotosUI

struct EnhancedAddSpotWaypointView: View {
    @ObservedObject var report: DTAReport
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    @State private var spotType = ""
    @State private var spotDescription = ""
    @State private var selectedPhotoItem: PhotosPickerItem?
    @State private var attachedPhotoData: Data?
    @State private var showingCamera = false
    @State private var showCameraUnavailableAlert = false
    @State private var isInitialized = false
    
    private let spotTypeOptions = [
        "Helispot/Pad",
        "No Work Zone (NWZ)",
        "Staging Area",
        "Water Source",
        "Safety Zone",
        "Equipment Cache",
        "Command Post",
        "Medical Station",
        "Fuel Depot",
        "Other"
    ]
    
    var spotLabel: String {
        let waypoints = report.waypointsArray
        let existingSpots = waypoints.filter { waypoint in
            waypoint.label?.starts(with: "Spot") == true
        }
        let spotNumber = existingSpots.count + 1
        
        if spotType.isEmpty {
            return "Spot \(spotNumber)"
        } else {
            return "Spot \(spotNumber) - \(spotType)"
        }
    }

    var body: some View {
        NavigationView {
            Form {
                spotTypeSection
                descriptionSection
                photoSection
                previewSection
            }
            .navigationTitle("Add Spot Waypoint")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                toolbarContent
            }
            .fullScreenCover(isPresented: $showingCamera) {
                cameraView
            }
            .onChange(of: selectedPhotoItem) { _, newItem in
                handlePhotoSelection(newItem)
            }
            .alert("Camera Not Available", isPresented: $showCameraUnavailableAlert) {
                Button("OK") {}
            } message: {
                Text("This device does not have a camera available.")
            }
        }
        .onAppear {
            initializeView()
        }
    }
    
    // MARK: - View Components
    
    private var spotTypeSection: some View {
        Section("Spot Type") {
            spotTypePicker
            if spotType == "Other" {
                otherSpotTypeField
            }
        }
    }
    
    private var spotTypePicker: some View {
        Picker("Select Spot Type", selection: $spotType) {
            Text("Select Type...").tag("")
            ForEach(spotTypeOptions, id: \.self) { option in
                Text(option).tag(option)
            }
        }
        .pickerStyle(.menu)
    }
    
    private var otherSpotTypeField: some View {
        TextField("Specify spot type", text: $spotDescription)
            .textFieldStyle(RoundedBorderTextFieldStyle())
    }
    
    private var descriptionSection: some View {
        Section("Description") {
            descriptionEditor
            descriptionHint
        }
    }
    
    private var descriptionEditor: some View {
        TextEditor(text: $spotDescription)
            .frame(height: 80)
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
            )
    }
    
    private var descriptionHint: some View {
        Text("Describe the spot location and any relevant details")
            .font(.caption)
            .foregroundColor(.secondary)
    }
    
    private var photoSection: some View {
        Section("Photo (Optional but Recommended)") {
            if hasAttachedPhoto {
                attachedPhotoView
            } else {
                photoSelectionView
            }
        }
    }
    
    private var attachedPhotoView: some View {
        VStack {
            if let data = attachedPhotoData,
               let uiImage = UIImage(data: data) {
                photoImageView(uiImage)
                photoLabelView
                removePhotoButton
            }
        }
    }
    
    private func photoImageView(_ image: UIImage) -> some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFit()
            .frame(maxHeight: 200)
            .cornerRadius(8)
    }
    
    private var photoLabelView: some View {
        Text("Photo will be labeled: \"\(spotLabel).jpg\"")
            .font(.caption)
            .foregroundColor(.secondary)
            .padding(.top, 4)
    }
    
    private var removePhotoButton: some View {
        Button("Remove Photo", role: .destructive) {
            removePhoto()
        }
    }
    
    private var photoSelectionView: some View {
        VStack(spacing: 12) {
            takePhotoButton
            photoLibrarySection
            photoHint
        }
    }
    
    private var takePhotoButton: some View {
        Button(action: handleTakePhotoTap) {
            photoButtonContent(icon: "camera", text: "Take Photo", color: .blue)
        }
    }
    
    private var photoLibrarySection: some View {
        VStack {
            PhotosPicker(
                selection: $selectedPhotoItem,
                matching: .images,
                photoLibrary: .shared()
            ) {
                photoButtonContent(icon: "photo.on.rectangle", text: "Choose from Library", color: .green)
            }
        }
    }
    
    private func photoButtonContent(icon: String, text: String, color: Color) -> some View {
        HStack {
            Image(systemName: icon)
            Text(text)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(color)
        .foregroundColor(.white)
        .cornerRadius(8)
    }
    
    private var photoHint: some View {
        Text("📸 Adding a photo helps identify the spot location")
            .font(.caption)
            .foregroundColor(.orange)
            .multilineTextAlignment(.center)
    }
    
    private var previewSection: some View {
        Section("Preview") {
            previewContent
        }
    }
    
    private var previewContent: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("Spot Label:")
                .font(.caption)
                .foregroundColor(.secondary)
            Text(spotLabel)
                .font(.headline)
                .foregroundColor(.orange)
        }
    }
    
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            cancelButton
        }
        ToolbarItem(placement: .confirmationAction) {
            addButton
        }
    }
    
    private var cancelButton: some View {
        Button("Cancel") {
            dismiss()
        }
    }
    
    private var addButton: some View {
        Button("Add Spot") {
            addSpotAndDismiss()
        }
        .disabled(shouldDisableAddButton)
    }
    
    private var cameraView: some View {
        ImagePicker(sourceType: .camera) { data in
            handleCameraResult(data)
        }
    }
    
    // MARK: - Computed Properties
    
    private var hasAttachedPhoto: Bool {
        attachedPhotoData != nil
    }
    
    private var shouldDisableAddButton: Bool {
        !isInitialized || spotType.isEmpty
    }
    
    // MARK: - Methods
    
    private func initializeView() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            isInitialized = true
        }
    }
    
    private func handleTakePhotoTap() {
        if UIImagePickerController.isSourceTypeAvailable(.camera) {
            showingCamera = true
        } else {
            showCameraUnavailableAlert = true
        }
    }
    
    private func handleCameraResult(_ data: Data?) {
        attachedPhotoData = data
    }
    
    private func handlePhotoSelection(_ newItem: PhotosPickerItem?) {
        Task {
            do {
                if let data = try await newItem?.loadTransferable(type: Data.self) {
                    await MainActor.run {
                        self.attachedPhotoData = data
                    }
                }
            } catch {
                print("Failed to load photo: \(error)")
            }
        }
    }
    
    private func removePhoto() {
        attachedPhotoData = nil
        selectedPhotoItem = nil
    }
    
    private func addSpotAndDismiss() {
        guard isInitialized else { return }
        
        let finalLabel = spotLabel
        let finalDescription = createFinalDescription()
        
        let newWaypoint = createWaypoint(label: finalLabel, description: finalDescription)
        
        if let photoData = attachedPhotoData {
            createPhotoAttachment(with: photoData, label: finalLabel)
        }
        
        saveAndDismiss()
    }
    
    private func createFinalDescription() -> String {
        if spotType == "Other" {
            return spotDescription
        } else if spotDescription.isEmpty {
            return spotType
        } else {
            return "\(spotType): \(spotDescription)"
        }
    }
    
    private func createWaypoint(label: String, description: String) -> DTAWaypoint {
        let newWaypoint = DTAWaypoint(context: viewContext)
        newWaypoint.id = UUID()
        newWaypoint.latitude = LocationHelper.shared.currentLatitude
        newWaypoint.longitude = LocationHelper.shared.currentLongitude
        newWaypoint.label = label
        newWaypoint.locationNotes = description
        newWaypoint.isSpotPoint = true
        newWaypoint.dtaReport = report
        return newWaypoint
    }
    
    private func createPhotoAttachment(with data: Data, label: String) {
        let attachment = MediaAttachment(context: viewContext)
        attachment.id = UUID()
        attachment.mediaType = "photo"
        attachment.photoTimestamp = Date()
        
        let sanitizedLabel = sanitizeFileName(label)
        attachment.fileName = "\(sanitizedLabel).jpg"
        
        savePhotoToDisk(data: data, attachment: attachment)
        attachment.dtaReport = report
    }
    
    private func sanitizeFileName(_ fileName: String) -> String {
        // Remove or replace characters that are not filesystem-safe
        let invalidCharacters = CharacterSet(charactersIn: "/\\?%*|\"<>:")
        return fileName
            .components(separatedBy: invalidCharacters)
            .joined(separator: "_")
            .replacingOccurrences(of: " ", with: "_")
    }
    
    private func savePhotoToDisk(data: Data, attachment: MediaAttachment) {
        guard let docsUrl = FileManager.default.urls(
            for: .documentDirectory,
            in: .userDomainMask
        ).first,
        let fileName = attachment.fileName else {
            print("Failed to get documents directory or filename")
            return
        }
        
        let fileUrl = docsUrl.appendingPathComponent(fileName)
        do {
            try data.write(to: fileUrl)
            attachment.fileURL = fileUrl.absoluteString
        } catch {
            print("Failed to write image data to disk: \(error)")
        }
    }
    
    private func saveAndDismiss() {
        do {
            try viewContext.save()
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                dismiss()
            }
        } catch {
            print("Failed to save new spot waypoint: \(error.localizedDescription)")
            dismiss()
        }
    }
}



===== ./PivotPointV3/ImagePicker.swift =====
import SwiftUI
import UIKit

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.dismiss) var dismiss
    var sourceType: UIImagePickerController.SourceType
    var onImagePicked: (Data?) -> Void

    func makeUIViewController(context: Context) -> UIViewController {
        // Check if the source type (e.g., camera) is actually available on the device.
        guard UIImagePickerController.isSourceTypeAvailable(sourceType) else {
            // If not available, print an error and return a placeholder view controller.
            print("Source type \(sourceType.rawValue) is not available.")
            // Immediately call the completion handler with nil to signal failure.
            DispatchQueue.main.async {
                onImagePicked(nil)
                dismiss()
            }
            return UIViewController()
        }
        
        let picker = UIImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        return picker
    }

    func updateUIViewController(_ uiViewController: UIViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }

        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            let imageData = (info[.originalImage] as? UIImage)?.jpegData(compressionQuality: 0.8)
            // Ensure we call back on the main thread.
            DispatchQueue.main.async {
                self.parent.onImagePicked(imageData)
                self.parent.dismiss()
            }
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            // Ensure we call back on the main thread.
            DispatchQueue.main.async {
                self.parent.onImagePicked(nil)
                self.parent.dismiss()
            }
        }
    }
}



===== ./PivotPointV3/PivotPointV3App.swift =====
import SwiftUI

@main
struct PivotPointV3App: App {
    let persistenceController = PersistenceController.shared
    @Environment(\.scenePhase) var scenePhase
    
    @StateObject private var userSettings = UserSettings()
    @State private var showSplash = true

    var body: some Scene {
        WindowGroup {
            Group {
                if showSplash {
                    SplashView()
                        .onAppear {
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                                withAnimation(.easeInOut) {
                                    showSplash = false
                                }
                            }
                        }
                } else {
                    MainMenuView()
                        .environmentObject(userSettings)
                        .environment(\.managedObjectContext, persistenceController.container.viewContext)
                }
            }
        }
        .onChange(of: scenePhase) { _, newPhase in
            if newPhase == .inactive || newPhase == .background {
                try? persistenceController.container.viewContext.save()
            }
        }
    }
}



===== ./PivotPointV3/CertificationView.swift =====
import SwiftUI

/// Placeholder view for Certification tracking section
struct CertificationView: View {
    var body: some View {
        NavigationView {
            VStack {
                Text("✅ Certification Tracker")
                    .font(.largeTitle)
                    .padding()

                Text("Track chainsaw, faller, or wildfire certifications here.")
                    .foregroundColor(.secondary)

                Spacer()
            }
            .navigationTitle("Certification")
        }
    }
}



===== ./PivotPointV3/FireCenterListView.swift =====
import SwiftUI

struct FireCenterListView: View {
    @EnvironmentObject var userSettings: UserSettings
    
    let fireCenters = [
        "Cariboo Fire Centre",
        "Coastal Fire Centre",
        "Kamloops Fire Centre",
        "Northwest Fire Centre",
        "Prince George Fire Centre",
        "Southeast Fire Centre",
        "Out of Province"
    ]

    var body: some View {
        List(fireCenters, id: \.self) { center in
            NavigationLink(center, value: center)
        }
        .listStyle(.insetGrouped)
        .navigationTitle("Fire Center")
        .navigationBarTitleDisplayMode(.inline)
        .background(HeaderView().ignoresSafeArea(edges: .top))
        .transparentNavigationBar()
    }
}



===== ./PivotPointV3/SupportingViews.swift =====
import SwiftUI
import PhotosUI

struct WaypointsListView: View {
    @ObservedObject var viewModel: DTAReportViewModel
        
    var body: some View {
        List {
            // Use waypointsArray from viewModel
            ForEach(viewModel.waypointsArray, id: \.objectID) { waypoint in
                HStack {
                    VStack(alignment: .leading) {
                        Text(waypoint.label ?? "Unnamed Waypoint").font(.headline)
                        Text(waypoint.ddmCoordinateString).font(.caption).foregroundColor(.secondary)
                    }
                    Spacer()
                }
            }
            .onDelete { indexSet in
                for index in indexSet {
                    let waypoint = viewModel.waypointsArray[index]
                    // Remove waypoint from context
                    viewModel.context.delete(waypoint)
                    viewModel.saveContext()
                }
            }
        }
        .navigationTitle("Waypoints")
    }
}

struct PhotosListView: View {
    @ObservedObject var viewModel: DTAReportViewModel
        
    var body: some View {
        ScrollView {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 150))]) {
                // Use images array from viewModel
                ForEach(viewModel.images) { image in
                    VStack {
                        Image(uiImage: image.image)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(height: 150)
                            .cornerRadius(8)
                        Button("Delete") {
                            // Remove the media attachment
                            viewModel.removeMediaAttachment(image.mediaAttachment)
                        }
                        .foregroundColor(.red)
                        .font(.caption)
                    }
                }
            }
            .padding()
        }
        .navigationTitle("Photos")
    }
}

struct SpotWaypointSheet: View {
    let latitude: Double
    let longitude: Double
    
    @State private var label: String = ""
    @State private var notes: String = ""
    
    let onSave: (Double, Double, String, String) -> Void
    let onCancel: () -> Void
        
    var body: some View {
        NavigationView {
            Form {
                Section("Location") {
                    HStack {
                        Text("Latitude:")
                        Spacer()
                        Text(String(format: "%.6f", latitude)).foregroundColor(.secondary)
                    }
                    HStack {
                        Text("Longitude:")
                        Spacer()
                        Text(String(format: "%.6f", longitude)).foregroundColor(.secondary)
                    }
                }
                Section("Waypoint Details") {
                    TextField("Label (e.g., 'Spot 1', 'Pump Site')", text: $label)
                    TextField("Notes", text: $notes, axis: .vertical)
                        .lineLimit(3...6)
                }
            }
            .navigationTitle("Spot Waypoint")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel", action: onCancel)
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        onSave(latitude, longitude, label, notes)
                    }
                    .disabled(label.isEmpty)
                }
            }
        }
    }
}



===== ./PivotPointV3/UserInfoEntryView.swift =====
import SwiftUI

/// View for editing user profile information
struct UserInfoEntryView: View {
    @EnvironmentObject var userSettings: UserSettings
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("User Information")) {
                    TextField("Full Name", text: $userSettings.userName)
                    TextField("Call Sign", text: $userSettings.callSign)
                    TextField("Crew / Company", text: $userSettings.crewName)
                }
            }
            .navigationTitle("Edit Profile")
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}



===== ./PivotPointV3/FireLogsView.swift =====
import SwiftUI

/// Placeholder view for Fire Logs section
struct FireLogsView: View {
    var body: some View {
        Text("Fire Logs View")
            .font(.title2)
            .foregroundColor(.secondary)
    }
}



===== ./PivotPointV3/AddFireFolderView.swift =====
import SwiftUI
import CoreData

struct AddFireFolderView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss

    @State private var fireNumber: String = ""
    let fireCenter: String

    var body: some View {
        ZStack {
            HeaderView()
                .frame(maxHeight: .infinity, alignment: .top)
            
            VStack(spacing: 0) {
                // Header with controls
                HStack {
                    Button("Cancel") { dismiss() }
                    Spacer()
                    Text("New Fire Log").font(.headline)
                    Spacer()
                    Button("Save") {
                        saveFolder()
                    }
                    .disabled(fireNumber.isEmpty)
                }
                .padding()
                .background(.thinMaterial)

                Form {
                    Section(header: Text("New Fire Details for \(fireCenter)")) {
                        TextField("Fire Number (e.g., G80123)", text: $fireNumber)
                    }
                }
                
                Spacer()
            }
            .padding(.top, 250)
        }
        .navigationBarHidden(true)
        .ignoresSafeArea(edges: .top)
    }
    
    private func saveFolder() {
        let newFolder = FireFolder(context: viewContext)
        newFolder.id = UUID()
        newFolder.fireNumber = fireNumber
        newFolder.folderName = "Fire \(fireNumber)"
        newFolder.fireCenter = self.fireCenter
        
        do {
            try viewContext.save()
            dismiss()
        } catch {
            print("Error saving FireFolder: \(error)")
        }
    }
}



===== ./PivotPointV3/DTAPicklists.swift =====
import Foundation

enum DTAPicklists {
    static let assessmentStartEndSpotOptions = [
        "Start (fill out all fields)",
        "End (see start for rest of this info.)",
        "Spot 1",
        "Spot 2",
        "Spot 3",
        "Spot 4",
        "Spot 5"
    ]
    
    static let saoOverviewOptions = ["Yes", "No"]
    
    static let saoBriefedToCrewOptions = ["Yes", "No - do not select this (communicate)"]
    
    static let primaryHazardsPresentOptions = [
        "Location or lean",
        "Deterioration of limbs, stem or roots",
        "Overhead hazards",
        "Physical Damage"
    ]
    
    static let activityOptions = [
        "Bucking/slashing", "Burn Off", "Fire Camp/Command Post", "Hand guard",
        "Heavy Eq./Heli staging, marshalling areas", "Heavy equipment use",
        "Heavy Vehicles - Trail/overgrown road", "Hose Trail (black)", "Hose trail (green)",
        "Light vehicle parking", "Line locating", "Maintained Resource Rd. Heavy Vehicles",
        "Med/heavy heli - rotor wash exposure", "Light/inter heli - rotor wash exposure",
        "Mop Up", "Manned pumpsite", "Patrol", "Road/trail travel - light vehicles (black)",
        "Road/trail travel - light vehicles (green)", "Tree falling (not DTF)",
        "Unmanned pumpsite (black)", "Unmanned pump site (green)"
    ]

    // UPDATED: Removed number prefixes and changed "Medium" to "Moderate"
    static let levelOfDisturbanceOptions = ["VLR", "Low", "Moderate", "High"]
    
    // UPDATED: Removed "Not Applicable" option as requested
    static let lodLowHazardsOptions = [
        ">50% cross section damage/decay",
        "Greatly >50% lateral root damage/decay",
        "Insecurely lodged/hung up",
        "Recent lean AND Root decay (>50%)",
        "Spongy snags (heart rot conks)"
    ]
    
    // UPDATED: Removed "Not Applicable" option as requested
    static let lodMediumFirLarchPineSpruceOptions = [
        "Split Trunk", "Roots Inspection", "Butt and Stem Cankers",
        "Dead Limbs", "Stem Damage", "Fungal Fruiting Bodies", "Witches' Broom",
        "Hazardous Top", "Tree lean (4-8 trees) >10% + root probs",
        "Tree Lean (Class 1-3) >15%+root probs", "Thick Sloughing Bark",
        "Multiple trees, multiple defects"
    ]
    
    // UPDATED: Removed "Not Applicable" option as requested
    static let lodMediumRedYellowCedarOptions = [
        "Dead Limbs", "Hazardous Top", "Multiple trees, Multiple Defects",
        "Root Inspection", "Sapwood Slabs", "Split Trunk", "Stem damage",
        "Tree Lean (class 1-3)", "Tree Lean (Class 4-8)"
    ]
    
    static let fuelTypeOptions = [
        "C1 spruce lichen woodland", "C2 boreal spruce", "C3 mature jack/lodgepole pine",
        "C4 immature jack/lodgepole pine", "C5 red and white pine", "C6 conifer plantation",
        "C7 ponderosa pine - Doulas Fir", "D1 leafless aspen", "M1 boreal mixed wood leafless",
        "M2 boreal mixed wood green", "M3 dead balsam fir mixed wood leafless",
        "M4 dead balsam fir mixed wood green", "O1a matted grass", "O1b standing grass",
        "S1 jack or lodgepole pine slash", "S2 white spruce/balsam slash",
        "S3 - coastal cedar/hemlock/douglas fir slash"
    ]
    
    static let dtaMarkingProtocolFollowedOptions = ["Yes", "No (explain in Comments)"]
    static let noWorkZonesOptions = ["Yes", "No (Do not click this - brief them)", "None marked"]
    static let assessedMin1_5TreeLengthsOptions = ["Yes", "No (Explain in Comments)"]
    static let assessDistanceFromWorkAreaOptions = ["1.5 TL or Strike Dist. (slope adjusted)", "2 Tree Lengths (Slope adjusted)"]
    static let areaBetweenPointsSafeForWorkOptions = ["Yes", "No (explain in comments)"]
    static let reassessmentNeededOptions = ["", "Everyday", "Every 3 days", "Not required"]
}



===== ./PivotPointV3/DTAReportView.swift =====
import SwiftUI
import CoreData
import PhotosUI

struct DTAReportView: View {
    @ObservedObject var viewModel: DTAReportViewModel
    
    @State private var fileToShare: ShareableFile?
    @State private var showValidationAlert = false
    @State private var missingFields: [String] = []

    init(viewModel: DTAReportViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        Form {
            // A Spacer is added as a section header to push the content down below the header area.
            Section(header: Spacer(minLength: 200)) {
                ReportMetadataSectionView(viewModel: viewModel)
            }
            
            Section("Assessment Waypoints") {
                WaypointSectionView(viewModel: viewModel)
            }
            
            Section("Daily Assessment") {
                DailyAssessmentSectionView(viewModel: viewModel)
            }
            
            Section("Level of Disturbance") {
                LevelOfDisturbanceSectionView(viewModel: viewModel)
            }
            
            Section("Fuel Types") {
                NavigationLink(destination: FuelTypeSelectionView(report: viewModel.report, context: viewModel.context)) {
                    HStack {
                        Text("Fuel Types")
                        Spacer()
                        Text(fuelTypeSummary)
                            .foregroundColor(.secondary)
                    }
                }
                .foregroundColor(hasFuelTypes ? .green : .primary)
            }
            
            Section("Assessment Protocol") {
                AssessmentProtocolSectionView(viewModel: viewModel)
            }
            
            Section("Additional Media") {
                PhotosSectionView(viewModel: viewModel)
            }
            
            Section("Additional Comments") {
                CommentsSectionView(comments: $viewModel.comments)
            }
            
            exportButtonsSection
        }
        .listStyle(.insetGrouped)
        .navigationTitle(viewModel.report.unwrappedReportTitle)
        .navigationBarTitleDisplayMode(.inline)
        .background(HeaderView().ignoresSafeArea(edges: .top))
        .transparentNavigationBar()
        .onDisappear {
            viewModel.saveContext()
        }
        .environment(\.managedObjectContext, viewModel.context)
        .sheet(item: $fileToShare) { file in
            ShareSheet(activityItems: [file.url]) {
                try? FileManager.default.removeItem(at: file.url)
            }
        }
        .alert("Missing Information", isPresented: $showValidationAlert) {
            Button("OK", role: .cancel) {}
        } message: {
            Text("Please fill out the following required fields before exporting:\n\n• " + missingFields.joined(separator: "\n• "))
        }
    }
    
    private var exportButtonsSection: some View {
        Section("Export Report") {
            HStack(spacing: 12) {
                exportButton(title: "KML", color: .blue, type: .kml)
                exportButton(title: "CSV", color: .green, type: .csv)
                exportButton(title: "PDF", color: .red, type: .pdf)
            }
            .frame(maxWidth: .infinity)
        }
    }
    
    private func exportButton(title: String, color: Color, type: ExportType) -> some View {
        Button(action: { validateAndExport(type: type) }) {
            Text(title)
                .fontWeight(.bold)
                .frame(maxWidth: .infinity)
        }
        .buttonStyle(.borderedProminent)
        .tint(color)
        .controlSize(.large)
    }
    
    private var fuelTypeSummary: String {
        let fuelTypes = viewModel.report.fuelTypes as? Set<FuelTypeSelection> ?? []
        if fuelTypes.isEmpty { return "Select..." }
        
        let sortedTypes = fuelTypes.sorted { $0.fuelType ?? "" < $1.fuelType ?? "" }
        
        let abbreviations = sortedTypes.compactMap { selection -> String? in
            guard let fuelType = selection.fuelType else { return nil }
            let code = fuelType.split(separator: " ").first ?? ""
            return "\(code)(\(selection.percentage)%)"
        }
        return abbreviations.joined(separator: ", ")
    }
    
    private var hasFuelTypes: Bool {
        !((viewModel.report.fuelTypes as? Set<FuelTypeSelection> ?? []).isEmpty)
    }
    
    private enum ExportType { case kml, csv, pdf }

    private func validateAndExport(type: ExportType) {
        let missing = viewModel.validateReport()
        if missing.isEmpty {
            export(type: type)
        } else {
            self.missingFields = missing
            self.showValidationAlert = true
        }
    }
    
    private func export(type: ExportType) {
        let exporter = DTAReportExporter()
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let dateString = dateFormatter.string(from: viewModel.report.manualDateTime ?? Date())
        let activityString = viewModel.activity.isEmpty ? "NoActivity" : viewModel.activity.replacingOccurrences(of: " ", with: "_")
        let exportTitle = "DTA-\(dateString)-\(activityString)"
        
        viewModel.reportTitle = exportTitle
        viewModel.saveContext()

        let fileName: String
        let data: Data?
        
        switch type {
        case .kml:
            fileName = "\(exportTitle).kml"
            data = exporter.generateKML(for: viewModel.report).data(using: .utf8)
        case .csv:
            fileName = "\(exportTitle).csv"
            data = exporter.generateCSV(for: viewModel.report).data(using: .utf8)
        case .pdf:
            fileName = "\(exportTitle).pdf"
            data = exporter.generatePDF(for: viewModel.report)
        }
        
        guard let fileData = data else { return }
        
        let tempUrl = FileManager.default.temporaryDirectory.appendingPathComponent(fileName)
        do {
            try fileData.write(to: tempUrl)
            self.fileToShare = ShareableFile(url: tempUrl)
        } catch {
            print("Failed to write export file: \(error)")
        }
    }
}



===== ./PivotPointV3/FireFolderDetailView.swift =====
import SwiftUI
import CoreData

struct FireFolderDetailView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @EnvironmentObject var userSettings: UserSettings
    @ObservedObject var fireFolder: FireFolder
    
    @State private var activeViewModel: DTAReportViewModel?
    @State private var showReportTypeSheet = false
    @State private var showEditSheet = false
    
    var body: some View {
        List {
            ForEach(fireFolder.dtaReportsArray) { report in
                NavigationLink(value: report) {
                    Text(report.unwrappedReportTitle)
                }
            }
            .onDelete(perform: deleteReports)
        }
        .listStyle(.insetGrouped)
        .navigationTitle(fireFolder.fireNumber ?? "Untitled Fire")
        .navigationBarTitleDisplayMode(.inline)
        .background(HeaderView().ignoresSafeArea(edges: .top))
        .transparentNavigationBar()
        .toolbar {
            ToolbarItemGroup(placement: .navigationBarTrailing) {
                Button("Edit") { showEditSheet = true }
                Button("Add") { showReportTypeSheet = true }
            }
        }
        .sheet(isPresented: $showReportTypeSheet) {
            ReportTypeSelectionSheet(
                fireFolder: fireFolder,
                onSelection: { reportType in
                    if reportType == "Create New DTA Report" {
                        if let newReport = createNewDtaReport() {
                            self.activeViewModel = DTAReportViewModel(report: newReport, parentContext: viewContext, userSettings: userSettings)
                        }
                    }
                    showReportTypeSheet = false
                }
            )
        }
        .sheet(isPresented: $showEditSheet) {
            EditFireFolderView(fireFolder: fireFolder)
        }
        // This destination handles navigating to a NEWLY created report
        .navigationDestination(item: $activeViewModel) { viewModel in
            DTAReportView(viewModel: viewModel)
        }
    }
    
    private func deleteReports(at offsets: IndexSet) {
        for index in offsets {
            let report = fireFolder.dtaReportsArray[index]
            viewContext.delete(report)
        }
        try? viewContext.save()
    }
    
    private func createNewDtaReport() -> DTAReport? {
        let newReport = DTAReport(context: viewContext)
        newReport.id = UUID()
        newReport.manualDateTime = Date()
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        let dateString = dateFormatter.string(from: Date())
        let userIdentifier = !userSettings.callSign.isEmpty ? userSettings.callSign : userSettings.userName
        newReport.reportTitle = "DTA Report - \(userIdentifier) - \(dateString)"
        
        newReport.fireFolder = fireFolder
        newReport.fireCenter = fireFolder.fireCenter
        newReport.fireNumber = fireFolder.fireNumber ?? ""
        newReport.assessedBy = userSettings.userName
        
        do {
            try viewContext.save()
            return newReport
        } catch {
            print("Failed to create DTA report: \(error)")
            return nil
        }
    }
}

// ReportTypeSelectionSheet remains unchanged
struct ReportTypeSelectionSheet: View {
    let fireFolder: FireFolder
    let onSelection: (String) -> Void
    @Environment(\.dismiss) private var dismiss
    
    private let reportTypes = [
        "Create New DTA Report",
        "Faller Inspection (Coming Soon)",
        "Helipad Inspection (Coming Soon)",
        "Hazard Report (Coming Soon)"
    ]
    
    var body: some View {
        NavigationView {
            List(reportTypes, id: \.self) { reportType in
                Button(action: {
                    if !reportType.contains("Coming Soon") {
                        onSelection(reportType)
                    }
                }) {
                    HStack {
                        Text(reportType)
                            .foregroundColor(reportType.contains("Coming Soon") ? .gray : .primary)
                        Spacer()
                        if reportType.contains("Coming Soon") {
                            Text("Soon")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                }
                .disabled(reportType.contains("Coming Soon"))
            }
            .navigationTitle("Select Report Type")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}



===== ./PivotPointV3/WaypointSectionView.swift =====
import SwiftUI
import CoreData
import CoreLocation

struct WaypointSectionView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @ObservedObject var viewModel: DTAReportViewModel
    @StateObject var locationHelper = LocationHelper.shared
    
    @State private var showAddSpotView = false
    @State private var showDeletionAlert = false
    @State private var isAddingWaypoint = false

    private var waypoints: [DTAWaypoint] { viewModel.waypointsArray }
    private var hasStartPoint: Bool { waypoints.contains { $0.isStartPoint } }
    private var hasEndPoint: Bool { waypoints.contains { $0.isEndPoint } }

    var body: some View {
        HStack {
            Button("Add Start") { addWaypoint(label: "Start", isStart: true) }
                .buttonStyle(.borderedProminent).tint(.green)
                .disabled(hasStartPoint || isAddingWaypoint)
            
            Button("Add End") { addWaypoint(label: "End", isEnd: true) }
                .buttonStyle(.borderedProminent).tint(.red)
                .disabled(!hasStartPoint || hasEndPoint || isAddingWaypoint)
            
            Button("Add Spot") { showAddSpotView = true }
                .buttonStyle(.borderedProminent).tint(.orange)
        }
        .frame(maxWidth: .infinity)

        ForEach(waypoints) { waypoint in
            HStack {
                Text(waypoint.label ?? "Waypoint").fontWeight(.semibold)
                    .foregroundColor(colorForWaypoint(label: waypoint.label))
                Spacer()
                Text(waypoint.ddmCoordinateString).font(.caption).foregroundColor(.secondary)
            }
        }
        .onDelete(perform: deleteWaypoint)
        .alert("Cannot Delete Start Point", isPresented: $showDeletionAlert) {
            Button("OK", role: .cancel) {}
        } message: {
            Text("You must delete the 'End' point before deleting the 'Start' point.")
        }
        .sheet(isPresented: $showAddSpotView) {
            AddSpotWaypointView(report: viewModel.report)
        }
    }
    
    private func addWaypoint(label: String, isStart: Bool = false, isEnd: Bool = false) {
        isAddingWaypoint = true
        let newWaypoint = DTAWaypoint(context: viewContext)
        newWaypoint.id = UUID()
        newWaypoint.label = label
        newWaypoint.latitude = locationHelper.currentLatitude
        newWaypoint.longitude = locationHelper.currentLongitude
        newWaypoint.isStartPoint = isStart
        newWaypoint.isEndPoint = isEnd
        newWaypoint.dtaReport = viewModel.report
        save()
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            isAddingWaypoint = false
        }
    }

    private func addSpotWaypoint() {
        showAddSpotView = true
    }

    private func deleteWaypoint(at offsets: IndexSet) {
        for index in offsets {
            let waypointToDelete = waypoints[index]
            if waypointToDelete.isStartPoint && hasEndPoint {
                showDeletionAlert = true
                return
            }
            viewContext.delete(waypointToDelete)
        }
        save()
    }

    private func save() {
        try? viewContext.save()
    }

    private func colorForWaypoint(label: String?) -> Color {
        guard let label = label else { return .primary }
        if label.starts(with: "Start") { return .green }
        if label.starts(with: "End") { return .red }
        if label.starts(with: "Spot") { return .orange }
        return .primary
    }
}



===== ./PivotPointV3/HeaderView.swift =====
import SwiftUI

struct HeaderView: View {
    let addAction: (() -> Void)?
    
    init(addAction: (() -> Void)? = nil) {
        self.addAction = addAction
    }

    var body: some View {
        VStack(spacing: 4) {
            Image("HeaderDark")
                .resizable()
                .scaledToFit()
                .frame(height: 350)
            
            Text("PRAEMONITUS PRAEMUNITUS")
                .font(.footnote)
                .fontWeight(.semibold)
                .foregroundColor(.secondary)
                .offset(y: -130)
        }
        .offset(y: -90)
        .overlay(alignment: .bottom) {
            if let addAction = addAction {
                HStack {
                    Spacer()
                    Button(action: addAction) {
                        Image(systemName: "plus.circle.fill")
                            .font(.title2)
                            .foregroundColor(.secondary)
                            .padding(10)
                            .background(.thinMaterial, in: Circle())
                    }
                }
                .padding(.horizontal)
                .offset(y: 15)
            }
        }
        .ignoresSafeArea(edges: .top)
    }
}



===== ./PivotPointV3/ExportView.swift =====
import SwiftUI

/// Placeholder view for exporting logs, data, and files
struct ExportView: View {
    var body: some View {
        NavigationView {
            VStack {
                Text("📤 Export Center")
                    .font(.largeTitle)
                    .padding()

                Text("Export your logs, data, and files from here.")
                    .foregroundColor(.secondary)

                Spacer()
            }
            .navigationTitle("Export")
        }
    }
}



===== ./PivotPointV3/View+TransparentNavbar.swift =====
import SwiftUI

/// A view modifier to make the navigation bar transparent.
struct TransparentNavigationBar: ViewModifier {
    func body(content: Content) -> some View {
        content
            .onAppear {
                let appearance = UINavigationBarAppearance()
                // Configure the appearance to be transparent
                appearance.configureWithTransparentBackground()
                
                // Apply this transparent appearance to all states of the navigation bar
                UINavigationBar.appearance().standardAppearance = appearance
                UINavigationBar.appearance().scrollEdgeAppearance = appearance
                UINavigationBar.appearance().compactAppearance = appearance
            }
            .onDisappear {
                // Restore the default navigation bar appearance when the view is no longer on screen
                let appearance = UINavigationBarAppearance()
                appearance.configureWithDefaultBackground()
                
                UINavigationBar.appearance().standardAppearance = appearance
                UINavigationBar.appearance().scrollEdgeAppearance = appearance
                UINavigationBar.appearance().compactAppearance = appearance
            }
    }
}

extension View {
    /// Applies a transparent navigation bar to the view.
    func transparentNavigationBar() -> some View {
        self.modifier(TransparentNavigationBar())
    }
}



===== ./PivotPointV3/SplashView.swift =====
import SwiftUI

/// Animated splash screen with a glowing, pulsing logo.
struct SplashView: View {
    @State private var animate = false

    var body: some View {
        ZStack {
            // Black background
            Color.black
                .ignoresSafeArea()

            // Glowing, pulsing logo
            Image("SplashLogo")
                .resizable()
                .scaledToFit()
                .frame(width: 220)
                // Glow effect
                .shadow(color: .orange.opacity(0.6), radius: animate ? 40 : 20)
                .shadow(color: .red.opacity(0.4), radius: animate ? 60 : 30)
                // Scaling effect for pulse
                .scaleEffect(animate ? 1.1 : 1.0)
                .opacity(animate ? 1.0 : 0.8)
                // Animation that repeats forever
                .animation(
                    .easeInOut(duration: 1.5).repeatForever(autoreverses: true),
                    value: animate
                )
        }
        .onAppear {
            animate = true
        }
    }
}



===== ./PivotPointV3/UserSettings.swift =====
import SwiftUI

/// Observable object to store user settings across the app
class UserSettings: ObservableObject {
    // User information stored in AppStorage for persistence
    @AppStorage("userName") var userName: String = ""
    @AppStorage("callSign") var callSign: String = ""
    @AppStorage("crewName") var crewName: String = ""
    
    // Lock state for app features
    @AppStorage("isLocked") var isLocked: Bool = false
    
    /// Returns true if all required user info fields are filled
    var isComplete: Bool {
        !userName.isEmpty && !callSign.isEmpty && !crewName.isEmpty
    }
}



===== ./PivotPointV3/ReportDetailsSectionView.swift =====
import SwiftUI
import CoreData

struct ReportDetailsSectionView: View {
    @ObservedObject var report: DTAReport
    
    var body: some View {
        Section("Report Details") {
            VStack(alignment: .leading, spacing: 4) {
                Text("Activity").font(.caption).foregroundColor(.secondary)
                TextField("Enter activity", text: $report.activity.unwrapped(with: ""))
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Assessment Start/End/Spot").font(.caption).foregroundColor(.secondary)
                TextField("Enter assessment details", text: $report.assessmentStartEndSpot.unwrapped(with: ""))
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Estimated Trees Felled").font(.caption).foregroundColor(.secondary)
                Stepper(value: Binding(
                    get: { Int(report.estimatedTreesFelled) },
                    set: { report.estimatedTreesFelled = Int16($0) }
                ), in: 0...1000) {
                    Text("\(report.estimatedTreesFelled)")
                }
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Primary Hazards Present").font(.caption).foregroundColor(.secondary)
                TextField("Enter primary hazards", text: $report.primaryHazardsPresent.unwrapped(with: ""), axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Level of Disturbance").font(.caption).foregroundColor(.secondary)
                TextField("Enter level of disturbance", text: $report.levelOfDisturbance.unwrapped(with: ""), axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Comments").font(.caption).foregroundColor(.secondary)
                TextField("Enter comments", text: $report.comments.unwrapped(with: ""), axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(3...6)
            }
        }
    }
}



===== ./PivotPointV3/ReferencesView.swift =====
import SwiftUI

/// Placeholder view for the Reference Library section
struct ReferencesView: View {
    var body: some View {
        NavigationView {
            VStack {
                Text("📚 Reference Library")
                    .font(.largeTitle)
                    .padding()

                Text("You can later add PDFs, SOPs, guides, etc.")
                    .foregroundColor(.secondary)

                Spacer()
            }
            .navigationTitle("References")
        }
    }
}



===== ./PivotPointV3/ShareableFile.swift =====
import Foundation

struct ShareableFile: Identifiable {
    let id = UUID()
    let url: URL
}



===== ./PivotPointV3/CircularIcon.swift =====
import SwiftUI

/// A circular icon with a gradient background and label
struct CircularIcon: View {
    let title: String
    let systemImage: String
    let color: Color

    var body: some View {
        VStack {
            ZStack {
                // Circular gradient background
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [color.opacity(0.9), color.opacity(0.6)]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 80, height: 80)
                    .shadow(color: color.opacity(0.4), radius: 6, x: 0, y: 4)

                // Icon on top
                Image(systemName: systemImage)
                    .foregroundColor(.white)
                    .font(.system(size: 28, weight: .bold))
            }

            Text(title)
                .font(.caption)
                .foregroundColor(.primary)
                .padding(.top, 4)
        }
    }
}



===== ./PivotPointV3/FireFolderListView.swift =====
import SwiftUI
import CoreData

struct FireFolderListView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @EnvironmentObject var userSettings: UserSettings
    
    @State private var showAddFireSheet = false
    
    private var fetchRequest: FetchRequest<FireFolder>
    private var folders: FetchedResults<FireFolder> {
        fetchRequest.wrappedValue
    }
    
    let fireCenter: String

    init(fireCenter: String) {
        self.fireCenter = fireCenter
        self.fetchRequest = FetchRequest(
            entity: FireFolder.entity(),
            sortDescriptors: [NSSortDescriptor(keyPath: \FireFolder.fireNumber, ascending: true)],
            predicate: NSPredicate(format: "fireCenter == %@", fireCenter)
        )
    }

    var body: some View {
        VStack(spacing: 0) {
            List {
                ForEach(folders) { folder in
                    NavigationLink(value: folder) {
                        Text(folder.folderName ?? "Untitled Fire")
                            .padding(.vertical, 6)
                    }
                }
                .onDelete(perform: deleteFolders)
            }
            .listStyle(.insetGrouped)

            Spacer()

            Button(action: { showAddFireSheet = true }) {
                Text("Add Fire")
                    .font(.headline)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.red)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                    .padding(.horizontal, 16)
            }
            .padding(.vertical)
        }
        .navigationTitle(fireCenter)
        .navigationBarTitleDisplayMode(.inline)
        .background(HeaderView().ignoresSafeArea(edges: .top))
        .transparentNavigationBar()
        .sheet(isPresented: $showAddFireSheet) {
            AddFireFolderView(fireCenter: self.fireCenter)
        }
    }
    
    private func deleteFolders(offsets: IndexSet) {
        for index in offsets {
            // FIXED: Corrected the typo here.
            viewContext.delete(folders[index])
        }
        try? viewContext.save()
    }
}



===== ./PivotPointV3/WaypointData.swift =====
import Foundation

struct WaypointData: Identifiable, Equatable {
    let id = UUID()
    var latitude: Double
    var longitude: Double
    var locationNotes: String
}



===== ./PivotPointV3/NSManagedObjectContext+Create.swift =====
import CoreData

extension NSManagedObjectContext {
    
    /// Creates a new Core Data object of the given type and automatically assigns a UUID to its `id` property if it exists.
    func create<T: NSManagedObject>(_ type: T.Type) -> T {
        let entityName = String(describing: type)
        
        guard let object = NSEntityDescription.insertNewObject(forEntityName: entityName, into: self) as? T else {
            fatalError("Failed to create \(entityName)")
        }
        
        // Automatically set UUID if the entity has an 'id' attribute
        if object.entity.attributesByName.keys.contains("id") {
            object.setValue(UUID(), forKey: "id")
        }
        
        return object
    }
}



===== ./PivotPointV3/HoverButtonView.swift =====
import SwiftUI

struct HoverButtonView: View {
    let systemImageName: String
    let label: String

    var body: some View {
        VStack {
            Image(systemName: systemImageName)
                .font(.title2)
                .frame(width: 44, height: 44)
            Text(label)
                .font(.caption)
        }
        .foregroundColor(.primary)
        .frame(maxWidth: .infinity)
        .padding(.vertical, 8)
    }
}



===== ./PivotPointV3/SaveButtonSectionView.swift =====
import SwiftUI
import CoreData

struct SaveButtonSectionView: View {
    @ObservedObject var report: DTAReport
    @ObservedObject var fireFolder: FireFolder
    let viewContext: NSManagedObjectContext
    
    @State private var showingAlert = false
    @State private var alertMessage = ""
    
    var body: some View {
        Section {
            Button(action: saveReport) {
                HStack {
                    Spacer()
                    Text("Save Report")
                        .fontWeight(.semibold)
                    Spacer()
                }
            }
            .buttonStyle(.borderedProminent)
            .controlSize(.large)
        }
        .alert("Save Status", isPresented: $showingAlert) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(alertMessage)
        }
    }
    
    private func saveReport() {
        do {
            // Ensure proper relationship setup
            if report.fireFolder != fireFolder {
                report.fireFolder = fireFolder
                fireFolder.addToDtaReports(report)
            }
            
            // Set default values if needed
            if report.id == nil {
                report.id = UUID()
            }
            
            try viewContext.save()
            alertMessage = "Report saved successfully!"
            showingAlert = true
        } catch {
            alertMessage = "Failed to save report: \(error.localizedDescription)"
            showingAlert = true
        }
    }
}



===== ./PivotPointV3/PressedHighlightButtonStyle.swift =====
import SwiftUI

// This custom ButtonStyle can now be used by any view in your app.
struct PressedHighlightButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .background(configuration.isPressed ? Color.gray.opacity(0.3) : Color.clear)
    }
}



===== ./PivotPointV3/LocationHelper.swift =====
import Foundation
import CoreLocation
import SwiftUI

class LocationHelper: NSObject, ObservableObject, CLLocationManagerDelegate {
    static let shared = LocationHelper()
    private let manager = CLLocationManager()

    @Published var lastLocation: CLLocation?
    @Published var isLocationReady = false // New property to track GPS readiness

    private override init() {
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = kCLLocationAccuracyBest
        manager.requestWhenInUseAuthorization()
        manager.startUpdatingLocation()
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if let newLocation = locations.last {
            lastLocation = newLocation
            
            // Consider location ready if horizontal accuracy is better than 100 meters
            if newLocation.horizontalAccuracy < 100 && !isLocationReady {
                DispatchQueue.main.async {
                    self.isLocationReady = true
                }
            }
        }
    }

    var currentLatitude: Double {
        lastLocation?.coordinate.latitude ?? 0
    }

    var currentLongitude: Double {
        lastLocation?.coordinate.longitude ?? 0
    }
}



===== ./PivotPointV3/ShareSheet.swift =====
import SwiftUI
import UIKit

struct ShareSheet: UIViewControllerRepresentable {
    let activityItems: [Any]
    let completion: (() -> Void)?

    func makeUIViewController(context: Context) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
        controller.completionWithItemsHandler = { _, _, _, _ in
            completion?()
        }
        return controller
    }

    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject {
        let parent: ShareSheet

        init(_ parent: ShareSheet) {
            self.parent = parent
        }
    }
}

extension ShareSheet {
    func present() {
        guard let windowScene = UIApplication.shared.connectedScenes.first(where: { $0.activationState == .foregroundActive }) as? UIWindowScene,
              let rootViewController = windowScene.windows.first?.rootViewController else {
            return
        }
        let activityViewController = UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
        activityViewController.completionWithItemsHandler = { _, _, _, _ in
            self.completion?()
        }
        rootViewController.present(activityViewController, animated: true, completion: nil)
    }
}



===== ./PivotPointV3/PersistenceController.swift =====
import CoreData
import Foundation

struct PersistenceController {
    static let shared = PersistenceController()

    static var preview: PersistenceController = {
        let result = PersistenceController(inMemory: true)
        let viewContext = result.container.viewContext

        let newFolder = FireFolder(context: viewContext)
        newFolder.id = UUID()
        newFolder.fireNumber = "2025-001"
        newFolder.folderName = "Preview Fire"
        newFolder.erpDocumentPath = "/erp/docs/2025-001"
        newFolder.iapDocumentPath = "/iap/docs/2025-001"

        let report1 = DTAReport(context: viewContext)
        report1.id = UUID()
        report1.reportTitle = "Preview Report Alpha"
        report1.assessedBy = "Preview User"
        report1.manualDateTime = Date()
        report1.fireNumber = "2025-001"
        report1.fireFolder = newFolder

        do {
            try viewContext.save()
        } catch {
            let nsError = error as NSError
            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
        }

        return result
    }()

    let container: NSPersistentContainer

    init(inMemory: Bool = false) {
        container = NSPersistentContainer(name: "Pivot_PointV2")

        if inMemory {
            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: "/dev/null")
        } else {
            // Step to reset the store: Delete the existing SQLite file if it exists
            let storeDescription = container.persistentStoreDescriptions.first
            if let url = storeDescription?.url {
                let fileManager = FileManager.default
                if fileManager.fileExists(atPath: url.path) {
                    do {
                        try fileManager.removeItem(at: url)
                        print("Successfully deleted old persistent store at \(url.path)")
                    } catch {
                        print("Failed to delete old persistent store: \(error.localizedDescription)")
                    }
                }
            }
        }

        // Keep lightweight migration enabled for future changes
        container.persistentStoreDescriptions.forEach { description in
            description.shouldMigrateStoreAutomatically = true
            description.shouldInferMappingModelAutomatically = true
        }

        container.loadPersistentStores { storeDescription, error in
            if let error = error as NSError? {
                print("Migration error: \(error), \(error.userInfo)")
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }

        container.viewContext.automaticallyMergesChangesFromParent = true
    }
}



